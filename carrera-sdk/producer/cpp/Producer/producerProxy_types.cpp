/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "producerProxy_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CarreraProducer {


Result::~Result() throw() {
}


void Result::__set_code(const int32_t val) {
  this->code = val;
}

void Result::__set_msg(const std::string& val) {
  this->msg = val;
}

void Result::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

const char* Result::ascii_fingerprint = "5531C8D7ED2A5FC0358A03FFBCC21464";
const uint8_t Result::binary_fingerprint[16] = {0x55,0x31,0xC8,0xD7,0xED,0x2A,0x5F,0xC0,0x35,0x8A,0x03,0xFF,0xBC,0xC2,0x14,0x64};

uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.msg, b.msg);
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other0) {
  code = other0.code;
  msg = other0.msg;
  key = other0.key;
  __isset = other0.__isset;
}
Result& Result::operator=(const Result& other1) {
  code = other1.code;
  msg = other1.msg;
  key = other1.key;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Result& obj) {
  using apache::thrift::to_string;
  out << "Result(";
  out << "code=" << to_string(obj.code);
  out << ", " << "msg=" << to_string(obj.msg);
  out << ", " << "key="; (obj.__isset.key ? (out << to_string(obj.key)) : (out << "<null>"));
  out << ")";
  return out;
}


RestMessage::~RestMessage() throw() {
}


void RestMessage::__set_type(const int8_t val) {
  this->type = val;
}

void RestMessage::__set_mode(const int8_t val) {
  this->mode = val;
}

void RestMessage::__set_url(const std::string& val) {
  this->url = val;
}

void RestMessage::__set_params(const std::map<std::string, std::string> & val) {
  this->params = val;
}

void RestMessage::__set_headers(const std::map<std::string, std::string> & val) {
  this->headers = val;
}

void RestMessage::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void RestMessage::__set_expire(const int64_t val) {
  this->expire = val;
}

void RestMessage::__set_timeout(const int64_t val) {
  this->timeout = val;
}

void RestMessage::__set_retryCnt(const int32_t val) {
  this->retryCnt = val;
}

const char* RestMessage::ascii_fingerprint = "CD67A2FB3005A51D7600603858CE44EB";
const uint8_t RestMessage::binary_fingerprint[16] = {0xCD,0x67,0xA2,0xFB,0x30,0x05,0xA5,0x1D,0x76,0x00,0x60,0x38,0x58,0xCE,0x44,0xEB};

uint32_t RestMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->params.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _ktype3;
            ::apache::thrift::protocol::TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _key7;
              xfer += iprot->readString(_key7);
              std::string& _val8 = this->params[_key7];
              xfer += iprot->readString(_val8);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headers.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              std::string _key14;
              xfer += iprot->readString(_key14);
              std::string& _val15 = this->headers[_key14];
              xfer += iprot->readString(_val15);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expire);
          this->__isset.expire = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retryCnt);
          this->__isset.retryCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RestMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("RestMessage");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::map<std::string, std::string> ::const_iterator _iter16;
    for (_iter16 = this->params.begin(); _iter16 != this->params.end(); ++_iter16)
    {
      xfer += oprot->writeString(_iter16->first);
      xfer += oprot->writeString(_iter16->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headers", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headers.size()));
    std::map<std::string, std::string> ::const_iterator _iter17;
    for (_iter17 = this->headers.begin(); _iter17 != this->headers.end(); ++_iter17)
    {
      xfer += oprot->writeString(_iter17->first);
      xfer += oprot->writeString(_iter17->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expire", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->expire);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retryCnt", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->retryCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(RestMessage &a, RestMessage &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.mode, b.mode);
  swap(a.url, b.url);
  swap(a.params, b.params);
  swap(a.headers, b.headers);
  swap(a.timestamp, b.timestamp);
  swap(a.expire, b.expire);
  swap(a.timeout, b.timeout);
  swap(a.retryCnt, b.retryCnt);
  swap(a.__isset, b.__isset);
}

RestMessage::RestMessage(const RestMessage& other18) {
  type = other18.type;
  mode = other18.mode;
  url = other18.url;
  params = other18.params;
  headers = other18.headers;
  timestamp = other18.timestamp;
  expire = other18.expire;
  timeout = other18.timeout;
  retryCnt = other18.retryCnt;
  __isset = other18.__isset;
}
RestMessage& RestMessage::operator=(const RestMessage& other19) {
  type = other19.type;
  mode = other19.mode;
  url = other19.url;
  params = other19.params;
  headers = other19.headers;
  timestamp = other19.timestamp;
  expire = other19.expire;
  timeout = other19.timeout;
  retryCnt = other19.retryCnt;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const RestMessage& obj) {
  using apache::thrift::to_string;
  out << "RestMessage(";
  out << "type=" << to_string(obj.type);
  out << ", " << "mode=" << to_string(obj.mode);
  out << ", " << "url=" << to_string(obj.url);
  out << ", " << "params=" << to_string(obj.params);
  out << ", " << "headers=" << to_string(obj.headers);
  out << ", " << "timestamp=" << to_string(obj.timestamp);
  out << ", " << "expire=" << to_string(obj.expire);
  out << ", " << "timeout=" << to_string(obj.timeout);
  out << ", " << "retryCnt=" << to_string(obj.retryCnt);
  out << ")";
  return out;
}


Message::~Message() throw() {
}


void Message::__set_topic(const std::string& val) {
  this->topic = val;
}

void Message::__set_key(const std::string& val) {
  this->key = val;
}

void Message::__set_value(const std::string& val) {
  this->value = val;
}

void Message::__set_hashId(const int64_t val) {
  this->hashId = val;
}

void Message::__set_tags(const std::string& val) {
  this->tags = val;
}

void Message::__set_partitionId(const int32_t val) {
  this->partitionId = val;
}

void Message::__set_body(const std::string& val) {
  this->body = val;
__isset.body = true;
}

void Message::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void Message::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

const char* Message::ascii_fingerprint = "B96D9A1911061E92CCF3412ED1DA2C63";
const uint8_t Message::binary_fingerprint[16] = {0xB9,0x6D,0x9A,0x19,0x11,0x06,0x1E,0x92,0xCC,0xF3,0x41,0x2E,0xD1,0xDA,0x2C,0x63};

uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hashId);
          this->__isset.hashId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partitionId);
          this->__isset.partitionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              std::string _key25;
              xfer += iprot->readString(_key25);
              std::string& _val26 = this->properties[_key25];
              xfer += iprot->readString(_val26);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Message");

  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->hashId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->tags);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionId", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->partitionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter27;
      for (_iter27 = this->properties.begin(); _iter27 != this->properties.end(); ++_iter27)
      {
        xfer += oprot->writeString(_iter27->first);
        xfer += oprot->writeString(_iter27->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Message &a, Message &b) {
  using ::std::swap;
  swap(a.topic, b.topic);
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.hashId, b.hashId);
  swap(a.tags, b.tags);
  swap(a.partitionId, b.partitionId);
  swap(a.body, b.body);
  swap(a.version, b.version);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Message::Message(const Message& other28) {
  topic = other28.topic;
  key = other28.key;
  value = other28.value;
  hashId = other28.hashId;
  tags = other28.tags;
  partitionId = other28.partitionId;
  body = other28.body;
  version = other28.version;
  properties = other28.properties;
  __isset = other28.__isset;
}
Message& Message::operator=(const Message& other29) {
  topic = other29.topic;
  key = other29.key;
  value = other29.value;
  hashId = other29.hashId;
  tags = other29.tags;
  partitionId = other29.partitionId;
  body = other29.body;
  version = other29.version;
  properties = other29.properties;
  __isset = other29.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Message& obj) {
  using apache::thrift::to_string;
  out << "Message(";
  out << "topic=" << to_string(obj.topic);
  out << ", " << "key=" << to_string(obj.key);
  out << ", " << "value=" << to_string(obj.value);
  out << ", " << "hashId=" << to_string(obj.hashId);
  out << ", " << "tags=" << to_string(obj.tags);
  out << ", " << "partitionId=" << to_string(obj.partitionId);
  out << ", " << "body="; (obj.__isset.body ? (out << to_string(obj.body)) : (out << "<null>"));
  out << ", " << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ", " << "properties="; (obj.__isset.properties ? (out << to_string(obj.properties)) : (out << "<null>"));
  out << ")";
  return out;
}


DelayResult::~DelayResult() throw() {
}


void DelayResult::__set_code(const int32_t val) {
  this->code = val;
}

void DelayResult::__set_msg(const std::string& val) {
  this->msg = val;
}

void DelayResult::__set_uniqDelayMsgId(const std::string& val) {
  this->uniqDelayMsgId = val;
}

const char* DelayResult::ascii_fingerprint = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
const uint8_t DelayResult::binary_fingerprint[16] = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};

uint32_t DelayResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uniqDelayMsgId);
          this->__isset.uniqDelayMsgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelayResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DelayResult");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uniqDelayMsgId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->uniqDelayMsgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DelayResult &a, DelayResult &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.msg, b.msg);
  swap(a.uniqDelayMsgId, b.uniqDelayMsgId);
  swap(a.__isset, b.__isset);
}

DelayResult::DelayResult(const DelayResult& other30) {
  code = other30.code;
  msg = other30.msg;
  uniqDelayMsgId = other30.uniqDelayMsgId;
  __isset = other30.__isset;
}
DelayResult& DelayResult::operator=(const DelayResult& other31) {
  code = other31.code;
  msg = other31.msg;
  uniqDelayMsgId = other31.uniqDelayMsgId;
  __isset = other31.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DelayResult& obj) {
  using apache::thrift::to_string;
  out << "DelayResult(";
  out << "code=" << to_string(obj.code);
  out << ", " << "msg=" << to_string(obj.msg);
  out << ", " << "uniqDelayMsgId=" << to_string(obj.uniqDelayMsgId);
  out << ")";
  return out;
}


DelayMessage::~DelayMessage() throw() {
}


void DelayMessage::__set_topic(const std::string& val) {
  this->topic = val;
}

void DelayMessage::__set_uniqDelayMsgId(const std::string& val) {
  this->uniqDelayMsgId = val;
__isset.uniqDelayMsgId = true;
}

void DelayMessage::__set_body(const std::string& val) {
  this->body = val;
__isset.body = true;
}

void DelayMessage::__set_tags(const std::string& val) {
  this->tags = val;
}

void DelayMessage::__set_action(const int32_t val) {
  this->action = val;
}

void DelayMessage::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void DelayMessage::__set_dmsgtype(const int32_t val) {
  this->dmsgtype = val;
__isset.dmsgtype = true;
}

void DelayMessage::__set_interval(const int64_t val) {
  this->interval = val;
__isset.interval = true;
}

void DelayMessage::__set_expire(const int64_t val) {
  this->expire = val;
__isset.expire = true;
}

void DelayMessage::__set_times(const int64_t val) {
  this->times = val;
__isset.times = true;
}

void DelayMessage::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void DelayMessage::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void DelayMessage::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

const char* DelayMessage::ascii_fingerprint = "8F73EBAF538EAC4D1570B7876B88042D";
const uint8_t DelayMessage::binary_fingerprint[16] = {0x8F,0x73,0xEB,0xAF,0x53,0x8E,0xAC,0x4D,0x15,0x70,0xB7,0x87,0x6B,0x88,0x04,0x2D};

uint32_t DelayMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uniqDelayMsgId);
          this->__isset.uniqDelayMsgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->action);
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dmsgtype);
          this->__isset.dmsgtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expire);
          this->__isset.expire = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->times);
          this->__isset.times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              std::string _key37;
              xfer += iprot->readString(_key37);
              std::string& _val38 = this->properties[_key37];
              xfer += iprot->readString(_val38);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelayMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DelayMessage");

  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.uniqDelayMsgId) {
    xfer += oprot->writeFieldBegin("uniqDelayMsgId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->uniqDelayMsgId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tags);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->action);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dmsgtype) {
    xfer += oprot->writeFieldBegin("dmsgtype", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->dmsgtype);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expire) {
    xfer += oprot->writeFieldBegin("expire", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->expire);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.times) {
    xfer += oprot->writeFieldBegin("times", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->times);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter39;
      for (_iter39 = this->properties.begin(); _iter39 != this->properties.end(); ++_iter39)
      {
        xfer += oprot->writeString(_iter39->first);
        xfer += oprot->writeString(_iter39->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DelayMessage &a, DelayMessage &b) {
  using ::std::swap;
  swap(a.topic, b.topic);
  swap(a.uniqDelayMsgId, b.uniqDelayMsgId);
  swap(a.body, b.body);
  swap(a.tags, b.tags);
  swap(a.action, b.action);
  swap(a.timestamp, b.timestamp);
  swap(a.dmsgtype, b.dmsgtype);
  swap(a.interval, b.interval);
  swap(a.expire, b.expire);
  swap(a.times, b.times);
  swap(a.uuid, b.uuid);
  swap(a.version, b.version);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

DelayMessage::DelayMessage(const DelayMessage& other40) {
  topic = other40.topic;
  uniqDelayMsgId = other40.uniqDelayMsgId;
  body = other40.body;
  tags = other40.tags;
  action = other40.action;
  timestamp = other40.timestamp;
  dmsgtype = other40.dmsgtype;
  interval = other40.interval;
  expire = other40.expire;
  times = other40.times;
  uuid = other40.uuid;
  version = other40.version;
  properties = other40.properties;
  __isset = other40.__isset;
}
DelayMessage& DelayMessage::operator=(const DelayMessage& other41) {
  topic = other41.topic;
  uniqDelayMsgId = other41.uniqDelayMsgId;
  body = other41.body;
  tags = other41.tags;
  action = other41.action;
  timestamp = other41.timestamp;
  dmsgtype = other41.dmsgtype;
  interval = other41.interval;
  expire = other41.expire;
  times = other41.times;
  uuid = other41.uuid;
  version = other41.version;
  properties = other41.properties;
  __isset = other41.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DelayMessage& obj) {
  using apache::thrift::to_string;
  out << "DelayMessage(";
  out << "topic=" << to_string(obj.topic);
  out << ", " << "uniqDelayMsgId="; (obj.__isset.uniqDelayMsgId ? (out << to_string(obj.uniqDelayMsgId)) : (out << "<null>"));
  out << ", " << "body="; (obj.__isset.body ? (out << to_string(obj.body)) : (out << "<null>"));
  out << ", " << "tags=" << to_string(obj.tags);
  out << ", " << "action=" << to_string(obj.action);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "dmsgtype="; (obj.__isset.dmsgtype ? (out << to_string(obj.dmsgtype)) : (out << "<null>"));
  out << ", " << "interval="; (obj.__isset.interval ? (out << to_string(obj.interval)) : (out << "<null>"));
  out << ", " << "expire="; (obj.__isset.expire ? (out << to_string(obj.expire)) : (out << "<null>"));
  out << ", " << "times="; (obj.__isset.times ? (out << to_string(obj.times)) : (out << "<null>"));
  out << ", " << "uuid="; (obj.__isset.uuid ? (out << to_string(obj.uuid)) : (out << "<null>"));
  out << ", " << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ", " << "properties="; (obj.__isset.properties ? (out << to_string(obj.properties)) : (out << "<null>"));
  out << ")";
  return out;
}


DelayMeta::~DelayMeta() throw() {
}


void DelayMeta::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void DelayMeta::__set_dmsgtype(const int32_t val) {
  this->dmsgtype = val;
__isset.dmsgtype = true;
}

void DelayMeta::__set_interval(const int64_t val) {
  this->interval = val;
__isset.interval = true;
}

void DelayMeta::__set_expire(const int64_t val) {
  this->expire = val;
__isset.expire = true;
}

void DelayMeta::__set_times(const int64_t val) {
  this->times = val;
__isset.times = true;
}

void DelayMeta::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

const char* DelayMeta::ascii_fingerprint = "CA1194C4201BE138211F48537B1200E0";
const uint8_t DelayMeta::binary_fingerprint[16] = {0xCA,0x11,0x94,0xC4,0x20,0x1B,0xE1,0x38,0x21,0x1F,0x48,0x53,0x7B,0x12,0x00,0xE0};

uint32_t DelayMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dmsgtype);
          this->__isset.dmsgtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expire);
          this->__isset.expire = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->times);
          this->__isset.times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              std::string _key47;
              xfer += iprot->readString(_key47);
              std::string& _val48 = this->properties[_key47];
              xfer += iprot->readString(_val48);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelayMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DelayMeta");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dmsgtype) {
    xfer += oprot->writeFieldBegin("dmsgtype", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->dmsgtype);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expire) {
    xfer += oprot->writeFieldBegin("expire", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->expire);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.times) {
    xfer += oprot->writeFieldBegin("times", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->times);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter49;
      for (_iter49 = this->properties.begin(); _iter49 != this->properties.end(); ++_iter49)
      {
        xfer += oprot->writeString(_iter49->first);
        xfer += oprot->writeString(_iter49->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DelayMeta &a, DelayMeta &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.dmsgtype, b.dmsgtype);
  swap(a.interval, b.interval);
  swap(a.expire, b.expire);
  swap(a.times, b.times);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

DelayMeta::DelayMeta(const DelayMeta& other50) {
  timestamp = other50.timestamp;
  dmsgtype = other50.dmsgtype;
  interval = other50.interval;
  expire = other50.expire;
  times = other50.times;
  properties = other50.properties;
  __isset = other50.__isset;
}
DelayMeta& DelayMeta::operator=(const DelayMeta& other51) {
  timestamp = other51.timestamp;
  dmsgtype = other51.dmsgtype;
  interval = other51.interval;
  expire = other51.expire;
  times = other51.times;
  properties = other51.properties;
  __isset = other51.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DelayMeta& obj) {
  using apache::thrift::to_string;
  out << "DelayMeta(";
  out << "timestamp=" << to_string(obj.timestamp);
  out << ", " << "dmsgtype="; (obj.__isset.dmsgtype ? (out << to_string(obj.dmsgtype)) : (out << "<null>"));
  out << ", " << "interval="; (obj.__isset.interval ? (out << to_string(obj.interval)) : (out << "<null>"));
  out << ", " << "expire="; (obj.__isset.expire ? (out << to_string(obj.expire)) : (out << "<null>"));
  out << ", " << "times="; (obj.__isset.times ? (out << to_string(obj.times)) : (out << "<null>"));
  out << ", " << "properties="; (obj.__isset.properties ? (out << to_string(obj.properties)) : (out << "<null>"));
  out << ")";
  return out;
}

} // namespace
