/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "carreraServiceDiscovery_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CarreraServiceDiscovery {


Endpoint::~Endpoint() throw() {
}


void Endpoint::__set_ip(const std::string& val) {
  this->ip = val;
}

void Endpoint::__set_port(const int32_t val) {
  this->port = val;
}

const char* Endpoint::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t Endpoint::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t Endpoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Endpoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Endpoint");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Endpoint &a, Endpoint &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

Endpoint::Endpoint(const Endpoint& other0) {
  ip = other0.ip;
  port = other0.port;
  __isset = other0.__isset;
}
Endpoint& Endpoint::operator=(const Endpoint& other1) {
  ip = other1.ip;
  port = other1.port;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Endpoint& obj) {
  using apache::thrift::to_string;
  out << "Endpoint(";
  out << "ip=" << to_string(obj.ip);
  out << ", " << "port=" << to_string(obj.port);
  out << ")";
  return out;
}


ClusterMeta::~ClusterMeta() throw() {
}


void ClusterMeta::__set_idc(const std::string& val) {
  this->idc = val;
}

void ClusterMeta::__set_clusterName(const std::string& val) {
  this->clusterName = val;
}

void ClusterMeta::__set_endpoints(const std::vector<Endpoint> & val) {
  this->endpoints = val;
}

const char* ClusterMeta::ascii_fingerprint = "12A8B9C13CB72040CC5B51A362762286";
const uint8_t ClusterMeta::binary_fingerprint[16] = {0x12,0xA8,0xB9,0xC1,0x3C,0xB7,0x20,0x40,0xCC,0x5B,0x51,0xA3,0x62,0x76,0x22,0x86};

uint32_t ClusterMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idc);
          this->__isset.idc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterName);
          this->__isset.clusterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->endpoints.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->endpoints[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClusterMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClusterMeta");

  xfer += oprot->writeFieldBegin("idc", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->idc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clusterName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->clusterName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<Endpoint> ::const_iterator _iter7;
    for (_iter7 = this->endpoints.begin(); _iter7 != this->endpoints.end(); ++_iter7)
    {
      xfer += (*_iter7).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ClusterMeta &a, ClusterMeta &b) {
  using ::std::swap;
  swap(a.idc, b.idc);
  swap(a.clusterName, b.clusterName);
  swap(a.endpoints, b.endpoints);
  swap(a.__isset, b.__isset);
}

ClusterMeta::ClusterMeta(const ClusterMeta& other8) {
  idc = other8.idc;
  clusterName = other8.clusterName;
  endpoints = other8.endpoints;
  __isset = other8.__isset;
}
ClusterMeta& ClusterMeta::operator=(const ClusterMeta& other9) {
  idc = other9.idc;
  clusterName = other9.clusterName;
  endpoints = other9.endpoints;
  __isset = other9.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ClusterMeta& obj) {
  using apache::thrift::to_string;
  out << "ClusterMeta(";
  out << "idc=" << to_string(obj.idc);
  out << ", " << "clusterName=" << to_string(obj.clusterName);
  out << ", " << "endpoints=" << to_string(obj.endpoints);
  out << ")";
  return out;
}


ConfigValue::~ConfigValue() throw() {
}


void ConfigValue::__set_userDefined(const bool val) {
  this->userDefined = val;
}

void ConfigValue::__set_value(const std::string& val) {
  this->value = val;
}

const char* ConfigValue::ascii_fingerprint = "1767FFB0CB3D9275BC64B198AB3B8A8B";
const uint8_t ConfigValue::binary_fingerprint[16] = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

uint32_t ConfigValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->userDefined);
          this->__isset.userDefined = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ConfigValue");

  xfer += oprot->writeFieldBegin("userDefined", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->userDefined);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ConfigValue &a, ConfigValue &b) {
  using ::std::swap;
  swap(a.userDefined, b.userDefined);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

ConfigValue::ConfigValue(const ConfigValue& other10) {
  userDefined = other10.userDefined;
  value = other10.value;
  __isset = other10.__isset;
}
ConfigValue& ConfigValue::operator=(const ConfigValue& other11) {
  userDefined = other11.userDefined;
  value = other11.value;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ConfigValue& obj) {
  using apache::thrift::to_string;
  out << "ConfigValue(";
  out << "userDefined=" << to_string(obj.userDefined);
  out << ", " << "value=" << to_string(obj.value);
  out << ")";
  return out;
}


ServiceMeta::~ServiceMeta() throw() {
}


void ServiceMeta::__set_metaVersion(const int64_t val) {
  this->metaVersion = val;
}

void ServiceMeta::__set_metaHash(const std::string& val) {
  this->metaHash = val;
}

void ServiceMeta::__set_metaList(const std::vector<ClusterMeta> & val) {
  this->metaList = val;
}

void ServiceMeta::__set_config(const std::map<std::string, std::string> & val) {
  this->config = val;
__isset.config = true;
}

const char* ServiceMeta::ascii_fingerprint = "3715871E09BDC3F4E66F9AE2A3E616E3";
const uint8_t ServiceMeta::binary_fingerprint[16] = {0x37,0x15,0x87,0x1E,0x09,0xBD,0xC3,0xF4,0xE6,0x6F,0x9A,0xE2,0xA3,0xE6,0x16,0xE3};

uint32_t ServiceMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->metaVersion);
          this->__isset.metaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaHash);
          this->__isset.metaHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metaList.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->metaList.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->metaList[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.metaList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->config.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _ktype18;
            ::apache::thrift::protocol::TType _vtype19;
            xfer += iprot->readMapBegin(_ktype18, _vtype19, _size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              std::string _key22;
              xfer += iprot->readString(_key22);
              std::string& _val23 = this->config[_key22];
              xfer += iprot->readString(_val23);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServiceMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ServiceMeta");

  xfer += oprot->writeFieldBegin("metaVersion", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->metaVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metaHash", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->metaHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metaList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metaList.size()));
    std::vector<ClusterMeta> ::const_iterator _iter24;
    for (_iter24 = this->metaList.begin(); _iter24 != this->metaList.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->config.size()));
      std::map<std::string, std::string> ::const_iterator _iter25;
      for (_iter25 = this->config.begin(); _iter25 != this->config.end(); ++_iter25)
      {
        xfer += oprot->writeString(_iter25->first);
        xfer += oprot->writeString(_iter25->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ServiceMeta &a, ServiceMeta &b) {
  using ::std::swap;
  swap(a.metaVersion, b.metaVersion);
  swap(a.metaHash, b.metaHash);
  swap(a.metaList, b.metaList);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

ServiceMeta::ServiceMeta(const ServiceMeta& other26) {
  metaVersion = other26.metaVersion;
  metaHash = other26.metaHash;
  metaList = other26.metaList;
  config = other26.config;
  __isset = other26.__isset;
}
ServiceMeta& ServiceMeta::operator=(const ServiceMeta& other27) {
  metaVersion = other27.metaVersion;
  metaHash = other27.metaHash;
  metaList = other27.metaList;
  config = other27.config;
  __isset = other27.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ServiceMeta& obj) {
  using apache::thrift::to_string;
  out << "ServiceMeta(";
  out << "metaVersion=" << to_string(obj.metaVersion);
  out << ", " << "metaHash=" << to_string(obj.metaHash);
  out << ", " << "metaList=" << to_string(obj.metaList);
  out << ", " << "config="; (obj.__isset.config ? (out << to_string(obj.config)) : (out << "<null>"));
  out << ")";
  return out;
}


ClientMeta::~ClientMeta() throw() {
}


void ClientMeta::__set_idc(const std::string& val) {
  this->idc = val;
}

void ClientMeta::__set_version(const std::string& val) {
  this->version = val;
}

void ClientMeta::__set_clientId(const std::string& val) {
  this->clientId = val;
}

void ClientMeta::__set_config(const std::map<std::string, ConfigValue> & val) {
  this->config = val;
__isset.config = true;
}

const char* ClientMeta::ascii_fingerprint = "7430B7012C109788A0D23F31C92B3C25";
const uint8_t ClientMeta::binary_fingerprint[16] = {0x74,0x30,0xB7,0x01,0x2C,0x10,0x97,0x88,0xA0,0xD2,0x3F,0x31,0xC9,0x2B,0x3C,0x25};

uint32_t ClientMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idc);
          this->__isset.idc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientId);
          this->__isset.clientId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->config.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _ktype29;
            ::apache::thrift::protocol::TType _vtype30;
            xfer += iprot->readMapBegin(_ktype29, _vtype30, _size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              std::string _key33;
              xfer += iprot->readString(_key33);
              ConfigValue& _val34 = this->config[_key33];
              xfer += _val34.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ClientMeta");

  xfer += oprot->writeFieldBegin("idc", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->idc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clientId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->clientId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->config.size()));
      std::map<std::string, ConfigValue> ::const_iterator _iter35;
      for (_iter35 = this->config.begin(); _iter35 != this->config.end(); ++_iter35)
      {
        xfer += oprot->writeString(_iter35->first);
        xfer += _iter35->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ClientMeta &a, ClientMeta &b) {
  using ::std::swap;
  swap(a.idc, b.idc);
  swap(a.version, b.version);
  swap(a.clientId, b.clientId);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

ClientMeta::ClientMeta(const ClientMeta& other36) {
  idc = other36.idc;
  version = other36.version;
  clientId = other36.clientId;
  config = other36.config;
  __isset = other36.__isset;
}
ClientMeta& ClientMeta::operator=(const ClientMeta& other37) {
  idc = other37.idc;
  version = other37.version;
  clientId = other37.clientId;
  config = other37.config;
  __isset = other37.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ClientMeta& obj) {
  using apache::thrift::to_string;
  out << "ClientMeta(";
  out << "idc=" << to_string(obj.idc);
  out << ", " << "version=" << to_string(obj.version);
  out << ", " << "clientId=" << to_string(obj.clientId);
  out << ", " << "config="; (obj.__isset.config ? (out << to_string(obj.config)) : (out << "<null>"));
  out << ")";
  return out;
}

} // namespace
