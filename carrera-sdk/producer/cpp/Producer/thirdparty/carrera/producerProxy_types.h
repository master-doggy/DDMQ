/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef producerProxy_TYPES_H
#define producerProxy_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace CarreraProducer {

class Result;

class RestMessage;

class Message;

class DelayResult;

class DelayMessage;

class DelayMeta;

typedef struct _Result__isset {
  _Result__isset() : code(false), msg(false), key(false) {}
  bool code :1;
  bool msg :1;
  bool key :1;
} _Result__isset;

class Result {
 public:

  static const char* ascii_fingerprint; // = "5531C8D7ED2A5FC0358A03FFBCC21464";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x31,0xC8,0xD7,0xED,0x2A,0x5F,0xC0,0x35,0x8A,0x03,0xFF,0xBC,0xC2,0x14,0x64};

  Result(const Result&);
  Result& operator=(const Result&);
  Result() : code(0), msg(), key() {
  }

  virtual ~Result() throw();
  int32_t code;
  std::string msg;
  std::string key;

  _Result__isset __isset;

  void __set_code(const int32_t val);

  void __set_msg(const std::string& val);

  void __set_key(const std::string& val);

  bool operator == (const Result & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(msg == rhs.msg))
      return false;
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Result& obj);
};

void swap(Result &a, Result &b);

typedef struct _RestMessage__isset {
  _RestMessage__isset() : type(true), mode(true), url(false), params(false), headers(false), timestamp(false), expire(false), timeout(false), retryCnt(true) {}
  bool type :1;
  bool mode :1;
  bool url :1;
  bool params :1;
  bool headers :1;
  bool timestamp :1;
  bool expire :1;
  bool timeout :1;
  bool retryCnt :1;
} _RestMessage__isset;

class RestMessage {
 public:

  static const char* ascii_fingerprint; // = "CD67A2FB3005A51D7600603858CE44EB";
  static const uint8_t binary_fingerprint[16]; // = {0xCD,0x67,0xA2,0xFB,0x30,0x05,0xA5,0x1D,0x76,0x00,0x60,0x38,0x58,0xCE,0x44,0xEB};

  RestMessage(const RestMessage&);
  RestMessage& operator=(const RestMessage&);
  RestMessage() : type(1), mode(1), url(), timestamp(0), expire(0), timeout(0), retryCnt(3) {
  }

  virtual ~RestMessage() throw();
  int8_t type;
  int8_t mode;
  std::string url;
  std::map<std::string, std::string>  params;
  std::map<std::string, std::string>  headers;
  int64_t timestamp;
  int64_t expire;
  int64_t timeout;
  int32_t retryCnt;

  _RestMessage__isset __isset;

  void __set_type(const int8_t val);

  void __set_mode(const int8_t val);

  void __set_url(const std::string& val);

  void __set_params(const std::map<std::string, std::string> & val);

  void __set_headers(const std::map<std::string, std::string> & val);

  void __set_timestamp(const int64_t val);

  void __set_expire(const int64_t val);

  void __set_timeout(const int64_t val);

  void __set_retryCnt(const int32_t val);

  bool operator == (const RestMessage & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(url == rhs.url))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(headers == rhs.headers))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(expire == rhs.expire))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    if (!(retryCnt == rhs.retryCnt))
      return false;
    return true;
  }
  bool operator != (const RestMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RestMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const RestMessage& obj);
};

void swap(RestMessage &a, RestMessage &b);

typedef struct _Message__isset {
  _Message__isset() : topic(false), key(false), value(false), hashId(false), tags(false), partitionId(true), body(false), version(false), properties(false) {}
  bool topic :1;
  bool key :1;
  bool value :1;
  bool hashId :1;
  bool tags :1;
  bool partitionId :1;
  bool body :1;
  bool version :1;
  bool properties :1;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "B96D9A1911061E92CCF3412ED1DA2C63";
  static const uint8_t binary_fingerprint[16]; // = {0xB9,0x6D,0x9A,0x19,0x11,0x06,0x1E,0x92,0xCC,0xF3,0x41,0x2E,0xD1,0xDA,0x2C,0x63};

  Message(const Message&);
  Message& operator=(const Message&);
  Message() : topic(), key(), value(), hashId(0), tags(), partitionId(-1), body(), version() {
  }

  virtual ~Message() throw();
  std::string topic;
  std::string key;
  std::string value;
  int64_t hashId;
  std::string tags;
  int32_t partitionId;
  std::string body;
  std::string version;
  std::map<std::string, std::string>  properties;

  _Message__isset __isset;

  void __set_topic(const std::string& val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  void __set_hashId(const int64_t val);

  void __set_tags(const std::string& val);

  void __set_partitionId(const int32_t val);

  void __set_body(const std::string& val);

  void __set_version(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const Message & rhs) const
  {
    if (!(topic == rhs.topic))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(hashId == rhs.hashId))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(partitionId == rhs.partitionId))
      return false;
    if (__isset.body != rhs.__isset.body)
      return false;
    else if (__isset.body && !(body == rhs.body))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Message& obj);
};

void swap(Message &a, Message &b);

typedef struct _DelayResult__isset {
  _DelayResult__isset() : code(false), msg(false), uniqDelayMsgId(false) {}
  bool code :1;
  bool msg :1;
  bool uniqDelayMsgId :1;
} _DelayResult__isset;

class DelayResult {
 public:

  static const char* ascii_fingerprint; // = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};

  DelayResult(const DelayResult&);
  DelayResult& operator=(const DelayResult&);
  DelayResult() : code(0), msg(), uniqDelayMsgId() {
  }

  virtual ~DelayResult() throw();
  int32_t code;
  std::string msg;
  std::string uniqDelayMsgId;

  _DelayResult__isset __isset;

  void __set_code(const int32_t val);

  void __set_msg(const std::string& val);

  void __set_uniqDelayMsgId(const std::string& val);

  bool operator == (const DelayResult & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(msg == rhs.msg))
      return false;
    if (!(uniqDelayMsgId == rhs.uniqDelayMsgId))
      return false;
    return true;
  }
  bool operator != (const DelayResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DelayResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DelayResult& obj);
};

void swap(DelayResult &a, DelayResult &b);

typedef struct _DelayMessage__isset {
  _DelayMessage__isset() : topic(false), uniqDelayMsgId(false), body(false), tags(false), action(false), timestamp(false), dmsgtype(false), interval(false), expire(false), times(false), uuid(false), version(false), properties(false) {}
  bool topic :1;
  bool uniqDelayMsgId :1;
  bool body :1;
  bool tags :1;
  bool action :1;
  bool timestamp :1;
  bool dmsgtype :1;
  bool interval :1;
  bool expire :1;
  bool times :1;
  bool uuid :1;
  bool version :1;
  bool properties :1;
} _DelayMessage__isset;

class DelayMessage {
 public:

  static const char* ascii_fingerprint; // = "8F73EBAF538EAC4D1570B7876B88042D";
  static const uint8_t binary_fingerprint[16]; // = {0x8F,0x73,0xEB,0xAF,0x53,0x8E,0xAC,0x4D,0x15,0x70,0xB7,0x87,0x6B,0x88,0x04,0x2D};

  DelayMessage(const DelayMessage&);
  DelayMessage& operator=(const DelayMessage&);
  DelayMessage() : topic(), uniqDelayMsgId(), body(), tags(), action(0), timestamp(0), dmsgtype(0), interval(0), expire(0), times(0), uuid(), version() {
  }

  virtual ~DelayMessage() throw();
  std::string topic;
  std::string uniqDelayMsgId;
  std::string body;
  std::string tags;
  int32_t action;
  int64_t timestamp;
  int32_t dmsgtype;
  int64_t interval;
  int64_t expire;
  int64_t times;
  std::string uuid;
  std::string version;
  std::map<std::string, std::string>  properties;

  _DelayMessage__isset __isset;

  void __set_topic(const std::string& val);

  void __set_uniqDelayMsgId(const std::string& val);

  void __set_body(const std::string& val);

  void __set_tags(const std::string& val);

  void __set_action(const int32_t val);

  void __set_timestamp(const int64_t val);

  void __set_dmsgtype(const int32_t val);

  void __set_interval(const int64_t val);

  void __set_expire(const int64_t val);

  void __set_times(const int64_t val);

  void __set_uuid(const std::string& val);

  void __set_version(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const DelayMessage & rhs) const
  {
    if (!(topic == rhs.topic))
      return false;
    if (__isset.uniqDelayMsgId != rhs.__isset.uniqDelayMsgId)
      return false;
    else if (__isset.uniqDelayMsgId && !(uniqDelayMsgId == rhs.uniqDelayMsgId))
      return false;
    if (__isset.body != rhs.__isset.body)
      return false;
    else if (__isset.body && !(body == rhs.body))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(action == rhs.action))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.dmsgtype != rhs.__isset.dmsgtype)
      return false;
    else if (__isset.dmsgtype && !(dmsgtype == rhs.dmsgtype))
      return false;
    if (__isset.interval != rhs.__isset.interval)
      return false;
    else if (__isset.interval && !(interval == rhs.interval))
      return false;
    if (__isset.expire != rhs.__isset.expire)
      return false;
    else if (__isset.expire && !(expire == rhs.expire))
      return false;
    if (__isset.times != rhs.__isset.times)
      return false;
    else if (__isset.times && !(times == rhs.times))
      return false;
    if (__isset.uuid != rhs.__isset.uuid)
      return false;
    else if (__isset.uuid && !(uuid == rhs.uuid))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const DelayMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DelayMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DelayMessage& obj);
};

void swap(DelayMessage &a, DelayMessage &b);

typedef struct _DelayMeta__isset {
  _DelayMeta__isset() : timestamp(false), dmsgtype(false), interval(false), expire(false), times(false), properties(false) {}
  bool timestamp :1;
  bool dmsgtype :1;
  bool interval :1;
  bool expire :1;
  bool times :1;
  bool properties :1;
} _DelayMeta__isset;

class DelayMeta {
 public:

  static const char* ascii_fingerprint; // = "CA1194C4201BE138211F48537B1200E0";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0x11,0x94,0xC4,0x20,0x1B,0xE1,0x38,0x21,0x1F,0x48,0x53,0x7B,0x12,0x00,0xE0};

  DelayMeta(const DelayMeta&);
  DelayMeta& operator=(const DelayMeta&);
  DelayMeta() : timestamp(0), dmsgtype(0), interval(0), expire(0), times(0) {
  }

  virtual ~DelayMeta() throw();
  int64_t timestamp;
  int32_t dmsgtype;
  int64_t interval;
  int64_t expire;
  int64_t times;
  std::map<std::string, std::string>  properties;

  _DelayMeta__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_dmsgtype(const int32_t val);

  void __set_interval(const int64_t val);

  void __set_expire(const int64_t val);

  void __set_times(const int64_t val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const DelayMeta & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (__isset.dmsgtype != rhs.__isset.dmsgtype)
      return false;
    else if (__isset.dmsgtype && !(dmsgtype == rhs.dmsgtype))
      return false;
    if (__isset.interval != rhs.__isset.interval)
      return false;
    else if (__isset.interval && !(interval == rhs.interval))
      return false;
    if (__isset.expire != rhs.__isset.expire)
      return false;
    else if (__isset.expire && !(expire == rhs.expire))
      return false;
    if (__isset.times != rhs.__isset.times)
      return false;
    else if (__isset.times && !(times == rhs.times))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const DelayMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DelayMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DelayMeta& obj);
};

void swap(DelayMeta &a, DelayMeta &b);

} // namespace

#endif
