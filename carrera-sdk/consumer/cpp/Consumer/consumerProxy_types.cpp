/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "consumerProxy_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CarreraConsumer {


Message::~Message() throw() {
}


void Message::__set_key(const std::string& val) {
  this->key = val;
}

void Message::__set_value(const std::string& val) {
  this->value = val;
}

void Message::__set_tag(const std::string& val) {
  this->tag = val;
}

void Message::__set_offset(const int64_t val) {
  this->offset = val;
}

void Message::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
  __isset.properties = true;
}

const char* Message::ascii_fingerprint = "5F9965D46A4F3845985AC0F9B81C3C69";
const uint8_t Message::binary_fingerprint[16] = {0x5F,0x99,0x65,0xD4,0x6A,0x4F,0x38,0x45,0x98,0x5A,0xC0,0xF9,0xB8,0x1C,0x3C,0x69};

uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tag);
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->properties[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
            break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Message");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->properties.begin(); _iter7 != this->properties.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Message &a, Message &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.tag, b.tag);
  swap(a.offset, b.offset);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Message::Message(const Message& other0) {
  key = other0.key;
  value = other0.value;
  tag = other0.tag;
  offset = other0.offset;
  properties = other0.properties;
  __isset = other0.__isset;
}
Message& Message::operator=(const Message& other1) {
  key = other1.key;
  value = other1.value;
  tag = other1.tag;
  offset = other1.offset;
  properties = other1.properties;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Message& obj) {
  using apache::thrift::to_string;
  out << "Message(";
  out << "key=" << to_string(obj.key);
  out << ", " << "value=" << to_string(obj.value);
  out << ", " << "tag=" << to_string(obj.tag);
  out << ", " << "offset=" << to_string(obj.offset);
  out << ", " << "properties="; (obj.__isset.properties ? (out << to_string(obj.properties)) : (out << "<null>"));
  out << ")";
  return out;
}


Context::~Context() throw() {
}


void Context::__set_groupId(const std::string& val) {
  this->groupId = val;
}

void Context::__set_topic(const std::string& val) {
  this->topic = val;
}

void Context::__set_qid(const std::string& val) {
  this->qid = val;
}

const char* Context::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t Context::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t Context::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qid);
          this->__isset.qid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Context::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Context");

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->groupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->qid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Context &a, Context &b) {
  using ::std::swap;
  swap(a.groupId, b.groupId);
  swap(a.topic, b.topic);
  swap(a.qid, b.qid);
  swap(a.__isset, b.__isset);
}

Context::Context(const Context& other2) {
  groupId = other2.groupId;
  topic = other2.topic;
  qid = other2.qid;
  __isset = other2.__isset;
}
Context& Context::operator=(const Context& other3) {
  groupId = other3.groupId;
  topic = other3.topic;
  qid = other3.qid;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Context& obj) {
  using apache::thrift::to_string;
  out << "Context(";
  out << "groupId=" << to_string(obj.groupId);
  out << ", " << "topic=" << to_string(obj.topic);
  out << ", " << "qid=" << to_string(obj.qid);
  out << ")";
  return out;
}


ConsumeResult::~ConsumeResult() throw() {
}


void ConsumeResult::__set_context(const Context& val) {
  this->context = val;
}

void ConsumeResult::__set_successOffsets(const std::vector<int64_t> & val) {
  this->successOffsets = val;
}

void ConsumeResult::__set_failOffsets(const std::vector<int64_t> & val) {
  this->failOffsets = val;
}

const char* ConsumeResult::ascii_fingerprint = "49084826B04BB3679061C8BC372B1450";
const uint8_t ConsumeResult::binary_fingerprint[16] = {0x49,0x08,0x48,0x26,0xB0,0x4B,0xB3,0x67,0x90,0x61,0xC8,0xBC,0x37,0x2B,0x14,0x50};

uint32_t ConsumeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->context.read(iprot);
          this->__isset.context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->successOffsets.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->successOffsets.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readI64(this->successOffsets[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.successOffsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->failOffsets.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->failOffsets.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += iprot->readI64(this->failOffsets[_i13]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.failOffsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ConsumeResult");

  xfer += oprot->writeFieldBegin("context", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->context.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("successOffsets", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->successOffsets.size()));
    std::vector<int64_t> ::const_iterator _iter14;
    for (_iter14 = this->successOffsets.begin(); _iter14 != this->successOffsets.end(); ++_iter14)
    {
      xfer += oprot->writeI64((*_iter14));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failOffsets", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->failOffsets.size()));
    std::vector<int64_t> ::const_iterator _iter15;
    for (_iter15 = this->failOffsets.begin(); _iter15 != this->failOffsets.end(); ++_iter15)
    {
      xfer += oprot->writeI64((*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ConsumeResult &a, ConsumeResult &b) {
  using ::std::swap;
  swap(a.context, b.context);
  swap(a.successOffsets, b.successOffsets);
  swap(a.failOffsets, b.failOffsets);
  swap(a.__isset, b.__isset);
}

ConsumeResult::ConsumeResult(const ConsumeResult& other16) {
  context = other16.context;
  successOffsets = other16.successOffsets;
  failOffsets = other16.failOffsets;
  __isset = other16.__isset;
}
ConsumeResult& ConsumeResult::operator=(const ConsumeResult& other17) {
  context = other17.context;
  successOffsets = other17.successOffsets;
  failOffsets = other17.failOffsets;
  __isset = other17.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ConsumeResult& obj) {
  using apache::thrift::to_string;
  out << "ConsumeResult(";
  out << "context=" << to_string(obj.context);
  out << ", " << "successOffsets=" << to_string(obj.successOffsets);
  out << ", " << "failOffsets=" << to_string(obj.failOffsets);
  out << ")";
  return out;
}


PullRequest::~PullRequest() throw() {
}


void PullRequest::__set_groupId(const std::string& val) {
  this->groupId = val;
}

void PullRequest::__set_topic(const std::string& val) {
  this->topic = val;
__isset.topic = true;
}

void PullRequest::__set_maxBatchSize(const int32_t val) {
  this->maxBatchSize = val;
__isset.maxBatchSize = true;
}

void PullRequest::__set_maxLingerTime(const int32_t val) {
  this->maxLingerTime = val;
__isset.maxLingerTime = true;
}

void PullRequest::__set_result(const ConsumeResult& val) {
  this->result = val;
__isset.result = true;
}

void PullRequest::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

const char* PullRequest::ascii_fingerprint = "8E7B6E318589AF347C2D248D82D6644F";
const uint8_t PullRequest::binary_fingerprint[16] = {0x8E,0x7B,0x6E,0x31,0x85,0x89,0xAF,0x34,0x7C,0x2D,0x24,0x8D,0x82,0xD6,0x64,0x4F};

uint32_t PullRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_groupId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupId);
          isset_groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBatchSize);
          this->__isset.maxBatchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxLingerTime);
          this->__isset.maxLingerTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_groupId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PullRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PullRequest");

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->groupId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.topic) {
    xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->topic);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxBatchSize) {
    xfer += oprot->writeFieldBegin("maxBatchSize", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->maxBatchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxLingerTime) {
    xfer += oprot->writeFieldBegin("maxLingerTime", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->maxLingerTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 50);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 60);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PullRequest &a, PullRequest &b) {
  using ::std::swap;
  swap(a.groupId, b.groupId);
  swap(a.topic, b.topic);
  swap(a.maxBatchSize, b.maxBatchSize);
  swap(a.maxLingerTime, b.maxLingerTime);
  swap(a.result, b.result);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

PullRequest::PullRequest(const PullRequest& other18) {
  groupId = other18.groupId;
  topic = other18.topic;
  maxBatchSize = other18.maxBatchSize;
  maxLingerTime = other18.maxLingerTime;
  result = other18.result;
  version = other18.version;
  __isset = other18.__isset;
}
PullRequest& PullRequest::operator=(const PullRequest& other19) {
  groupId = other19.groupId;
  topic = other19.topic;
  maxBatchSize = other19.maxBatchSize;
  maxLingerTime = other19.maxLingerTime;
  result = other19.result;
  version = other19.version;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PullRequest& obj) {
  using apache::thrift::to_string;
  out << "PullRequest(";
  out << "groupId=" << to_string(obj.groupId);
  out << ", " << "topic="; (obj.__isset.topic ? (out << to_string(obj.topic)) : (out << "<null>"));
  out << ", " << "maxBatchSize="; (obj.__isset.maxBatchSize ? (out << to_string(obj.maxBatchSize)) : (out << "<null>"));
  out << ", " << "maxLingerTime="; (obj.__isset.maxLingerTime ? (out << to_string(obj.maxLingerTime)) : (out << "<null>"));
  out << ", " << "result="; (obj.__isset.result ? (out << to_string(obj.result)) : (out << "<null>"));
  out << ", " << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ")";
  return out;
}


PullResponse::~PullResponse() throw() {
}


void PullResponse::__set_context(const Context& val) {
  this->context = val;
}

void PullResponse::__set_messages(const std::vector<Message> & val) {
  this->messages = val;
}

const char* PullResponse::ascii_fingerprint = "747C01C432C2D84503C2B635B8CB58F3";
const uint8_t PullResponse::binary_fingerprint[16] = {0x74,0x7C,0x01,0xC4,0x32,0xC2,0xD8,0x45,0x03,0xC2,0xB6,0x35,0xB8,0xCB,0x58,0xF3};

uint32_t PullResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->context.read(iprot);
          this->__isset.context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->messages.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->messages.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->messages[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.messages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PullResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PullResponse");

  xfer += oprot->writeFieldBegin("context", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->context.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messages", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->messages.size()));
    std::vector<Message> ::const_iterator _iter25;
    for (_iter25 = this->messages.begin(); _iter25 != this->messages.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PullResponse &a, PullResponse &b) {
  using ::std::swap;
  swap(a.context, b.context);
  swap(a.messages, b.messages);
  swap(a.__isset, b.__isset);
}

PullResponse::PullResponse(const PullResponse& other26) {
  context = other26.context;
  messages = other26.messages;
  __isset = other26.__isset;
}
PullResponse& PullResponse::operator=(const PullResponse& other27) {
  context = other27.context;
  messages = other27.messages;
  __isset = other27.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PullResponse& obj) {
  using apache::thrift::to_string;
  out << "PullResponse(";
  out << "context=" << to_string(obj.context);
  out << ", " << "messages=" << to_string(obj.messages);
  out << ")";
  return out;
}


ConsumeStatsRequest::~ConsumeStatsRequest() throw() {
}


void ConsumeStatsRequest::__set_group(const std::string& val) {
  this->group = val;
}

void ConsumeStatsRequest::__set_topic(const std::string& val) {
  this->topic = val;
__isset.topic = true;
}

void ConsumeStatsRequest::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

const char* ConsumeStatsRequest::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t ConsumeStatsRequest::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t ConsumeStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_group = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          isset_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_group)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ConsumeStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ConsumeStatsRequest");

  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.topic) {
    xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->topic);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ConsumeStatsRequest &a, ConsumeStatsRequest &b) {
  using ::std::swap;
  swap(a.group, b.group);
  swap(a.topic, b.topic);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

ConsumeStatsRequest::ConsumeStatsRequest(const ConsumeStatsRequest& other28) {
  group = other28.group;
  topic = other28.topic;
  version = other28.version;
  __isset = other28.__isset;
}
ConsumeStatsRequest& ConsumeStatsRequest::operator=(const ConsumeStatsRequest& other29) {
  group = other29.group;
  topic = other29.topic;
  version = other29.version;
  __isset = other29.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ConsumeStatsRequest& obj) {
  using apache::thrift::to_string;
  out << "ConsumeStatsRequest(";
  out << "group=" << to_string(obj.group);
  out << ", " << "topic="; (obj.__isset.topic ? (out << to_string(obj.topic)) : (out << "<null>"));
  out << ", " << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ")";
  return out;
}


FetchRequest::~FetchRequest() throw() {
}


void FetchRequest::__set_consumerId(const std::string& val) {
  this->consumerId = val;
}

void FetchRequest::__set_groupId(const std::string& val) {
  this->groupId = val;
}

void FetchRequest::__set_cluster(const std::string& val) {
  this->cluster = val;
}

void FetchRequest::__set_fetchOffset(const std::map<std::string, std::map<std::string, int64_t> > & val) {
  this->fetchOffset = val;
__isset.fetchOffset = true;
}

void FetchRequest::__set_maxBatchSize(const int32_t val) {
  this->maxBatchSize = val;
__isset.maxBatchSize = true;
}

void FetchRequest::__set_maxLingerTime(const int32_t val) {
  this->maxLingerTime = val;
__isset.maxLingerTime = true;
}

void FetchRequest::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

const char* FetchRequest::ascii_fingerprint = "906773A8CD439B466BD075DB396E9FD4";
const uint8_t FetchRequest::binary_fingerprint[16] = {0x90,0x67,0x73,0xA8,0xCD,0x43,0x9B,0x46,0x6B,0xD0,0x75,0xDB,0x39,0x6E,0x9F,0xD4};

uint32_t FetchRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_consumerId = false;
  bool isset_groupId = false;
  bool isset_cluster = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->consumerId);
          isset_consumerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupId);
          isset_groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          isset_cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fetchOffset.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              std::map<std::string, int64_t> & _val36 = this->fetchOffset[_key35];
              {
                _val36.clear();
                uint32_t _size37;
                ::apache::thrift::protocol::TType _ktype38;
                ::apache::thrift::protocol::TType _vtype39;
                xfer += iprot->readMapBegin(_ktype38, _vtype39, _size37);
                uint32_t _i41;
                for (_i41 = 0; _i41 < _size37; ++_i41)
                {
                  std::string _key42;
                  xfer += iprot->readString(_key42);
                  int64_t& _val43 = _val36[_key42];
                  xfer += iprot->readI64(_val43);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fetchOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBatchSize);
          this->__isset.maxBatchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxLingerTime);
          this->__isset.maxLingerTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_consumerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cluster)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FetchRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("FetchRequest");

  xfer += oprot->writeFieldBegin("consumerId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->consumerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->groupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cluster);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchOffset) {
    xfer += oprot->writeFieldBegin("fetchOffset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->fetchOffset.size()));
      std::map<std::string, std::map<std::string, int64_t> > ::const_iterator _iter44;
      for (_iter44 = this->fetchOffset.begin(); _iter44 != this->fetchOffset.end(); ++_iter44)
      {
        xfer += oprot->writeString(_iter44->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter44->second.size()));
          std::map<std::string, int64_t> ::const_iterator _iter45;
          for (_iter45 = _iter44->second.begin(); _iter45 != _iter44->second.end(); ++_iter45)
          {
            xfer += oprot->writeString(_iter45->first);
            xfer += oprot->writeI64(_iter45->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxBatchSize) {
    xfer += oprot->writeFieldBegin("maxBatchSize", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->maxBatchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxLingerTime) {
    xfer += oprot->writeFieldBegin("maxLingerTime", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->maxLingerTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 60);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(FetchRequest &a, FetchRequest &b) {
  using ::std::swap;
  swap(a.consumerId, b.consumerId);
  swap(a.groupId, b.groupId);
  swap(a.cluster, b.cluster);
  swap(a.fetchOffset, b.fetchOffset);
  swap(a.maxBatchSize, b.maxBatchSize);
  swap(a.maxLingerTime, b.maxLingerTime);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

FetchRequest::FetchRequest(const FetchRequest& other46) {
  consumerId = other46.consumerId;
  groupId = other46.groupId;
  cluster = other46.cluster;
  fetchOffset = other46.fetchOffset;
  maxBatchSize = other46.maxBatchSize;
  maxLingerTime = other46.maxLingerTime;
  version = other46.version;
  __isset = other46.__isset;
}
FetchRequest& FetchRequest::operator=(const FetchRequest& other47) {
  consumerId = other47.consumerId;
  groupId = other47.groupId;
  cluster = other47.cluster;
  fetchOffset = other47.fetchOffset;
  maxBatchSize = other47.maxBatchSize;
  maxLingerTime = other47.maxLingerTime;
  version = other47.version;
  __isset = other47.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const FetchRequest& obj) {
  using apache::thrift::to_string;
  out << "FetchRequest(";
  out << "consumerId=" << to_string(obj.consumerId);
  out << ", " << "groupId=" << to_string(obj.groupId);
  out << ", " << "cluster=" << to_string(obj.cluster);
  out << ", " << "fetchOffset="; (obj.__isset.fetchOffset ? (out << to_string(obj.fetchOffset)) : (out << "<null>"));
  out << ", " << "maxBatchSize="; (obj.__isset.maxBatchSize ? (out << to_string(obj.maxBatchSize)) : (out << "<null>"));
  out << ", " << "maxLingerTime="; (obj.__isset.maxLingerTime ? (out << to_string(obj.maxLingerTime)) : (out << "<null>"));
  out << ", " << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ")";
  return out;
}


QidResponse::~QidResponse() throw() {
}


void QidResponse::__set_topic(const std::string& val) {
  this->topic = val;
}

void QidResponse::__set_qid(const std::string& val) {
  this->qid = val;
}

void QidResponse::__set_nextRequestOffset(const int64_t val) {
  this->nextRequestOffset = val;
__isset.nextRequestOffset = true;
}

void QidResponse::__set_messages(const std::vector<Message> & val) {
  this->messages = val;
}

const char* QidResponse::ascii_fingerprint = "D27932A420DED5C23617C48CBE8CC55E";
const uint8_t QidResponse::binary_fingerprint[16] = {0xD2,0x79,0x32,0xA4,0x20,0xDE,0xD5,0xC2,0x36,0x17,0xC4,0x8C,0xBE,0x8C,0xC5,0x5E};

uint32_t QidResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topic = false;
  bool isset_qid = false;
  bool isset_messages = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          isset_topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qid);
          isset_qid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nextRequestOffset);
          this->__isset.nextRequestOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->messages.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->messages.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->messages[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_messages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topic)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_messages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QidResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("QidResponse");

  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->qid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.nextRequestOffset) {
    xfer += oprot->writeFieldBegin("nextRequestOffset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->nextRequestOffset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("messages", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->messages.size()));
    std::vector<Message> ::const_iterator _iter53;
    for (_iter53 = this->messages.begin(); _iter53 != this->messages.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(QidResponse &a, QidResponse &b) {
  using ::std::swap;
  swap(a.topic, b.topic);
  swap(a.qid, b.qid);
  swap(a.nextRequestOffset, b.nextRequestOffset);
  swap(a.messages, b.messages);
  swap(a.__isset, b.__isset);
}

QidResponse::QidResponse(const QidResponse& other54) {
  topic = other54.topic;
  qid = other54.qid;
  nextRequestOffset = other54.nextRequestOffset;
  messages = other54.messages;
  __isset = other54.__isset;
}
QidResponse& QidResponse::operator=(const QidResponse& other55) {
  topic = other55.topic;
  qid = other55.qid;
  nextRequestOffset = other55.nextRequestOffset;
  messages = other55.messages;
  __isset = other55.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const QidResponse& obj) {
  using apache::thrift::to_string;
  out << "QidResponse(";
  out << "topic=" << to_string(obj.topic);
  out << ", " << "qid=" << to_string(obj.qid);
  out << ", " << "nextRequestOffset="; (obj.__isset.nextRequestOffset ? (out << to_string(obj.nextRequestOffset)) : (out << "<null>"));
  out << ", " << "messages=" << to_string(obj.messages);
  out << ")";
  return out;
}


FetchResponse::~FetchResponse() throw() {
}


void FetchResponse::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

void FetchResponse::__set_results(const std::vector<QidResponse> & val) {
  this->results = val;
}

const char* FetchResponse::ascii_fingerprint = "B56E50C806471F5271B7B3E2704047F5";
const uint8_t FetchResponse::binary_fingerprint[16] = {0xB5,0x6E,0x50,0xC8,0x06,0x47,0x1F,0x52,0x71,0xB7,0xB3,0xE2,0x70,0x40,0x47,0xF5};

uint32_t FetchResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->results.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->results[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FetchResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("FetchResponse");

  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<QidResponse> ::const_iterator _iter61;
    for (_iter61 = this->results.begin(); _iter61 != this->results.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(FetchResponse &a, FetchResponse &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.results, b.results);
  swap(a.__isset, b.__isset);
}

FetchResponse::FetchResponse(const FetchResponse& other62) {
  code = other62.code;
  results = other62.results;
  __isset = other62.__isset;
}
FetchResponse& FetchResponse::operator=(const FetchResponse& other63) {
  code = other63.code;
  results = other63.results;
  __isset = other63.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const FetchResponse& obj) {
  using apache::thrift::to_string;
  out << "FetchResponse(";
  out << "code="; (obj.__isset.code ? (out << to_string(obj.code)) : (out << "<null>"));
  out << ", " << "results=" << to_string(obj.results);
  out << ")";
  return out;
}


AckResult::~AckResult() throw() {
}


void AckResult::__set_consumerId(const std::string& val) {
  this->consumerId = val;
}

void AckResult::__set_groupId(const std::string& val) {
  this->groupId = val;
}

void AckResult::__set_cluster(const std::string& val) {
  this->cluster = val;
}

void AckResult::__set_offsets(const std::map<std::string, std::map<std::string, int64_t> > & val) {
  this->offsets = val;
}

const char* AckResult::ascii_fingerprint = "3F9AC3B359E37DC260749F3B0D4910E4";
const uint8_t AckResult::binary_fingerprint[16] = {0x3F,0x9A,0xC3,0xB3,0x59,0xE3,0x7D,0xC2,0x60,0x74,0x9F,0x3B,0x0D,0x49,0x10,0xE4};

uint32_t AckResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_consumerId = false;
  bool isset_groupId = false;
  bool isset_cluster = false;
  bool isset_offsets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->consumerId);
          isset_consumerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupId);
          isset_groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          isset_cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::map<std::string, int64_t> & _val70 = this->offsets[_key69];
              {
                _val70.clear();
                uint32_t _size71;
                ::apache::thrift::protocol::TType _ktype72;
                ::apache::thrift::protocol::TType _vtype73;
                xfer += iprot->readMapBegin(_ktype72, _vtype73, _size71);
                uint32_t _i75;
                for (_i75 = 0; _i75 < _size71; ++_i75)
                {
                  std::string _key76;
                  xfer += iprot->readString(_key76);
                  int64_t& _val77 = _val70[_key76];
                  xfer += iprot->readI64(_val77);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_consumerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cluster)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_offsets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AckResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AckResult");

  xfer += oprot->writeFieldBegin("consumerId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->consumerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->groupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cluster);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->offsets.size()));
    std::map<std::string, std::map<std::string, int64_t> > ::const_iterator _iter78;
    for (_iter78 = this->offsets.begin(); _iter78 != this->offsets.end(); ++_iter78)
    {
      xfer += oprot->writeString(_iter78->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter78->second.size()));
        std::map<std::string, int64_t> ::const_iterator _iter79;
        for (_iter79 = _iter78->second.begin(); _iter79 != _iter78->second.end(); ++_iter79)
        {
          xfer += oprot->writeString(_iter79->first);
          xfer += oprot->writeI64(_iter79->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AckResult &a, AckResult &b) {
  using ::std::swap;
  swap(a.consumerId, b.consumerId);
  swap(a.groupId, b.groupId);
  swap(a.cluster, b.cluster);
  swap(a.offsets, b.offsets);
}

AckResult::AckResult(const AckResult& other80) {
  consumerId = other80.consumerId;
  groupId = other80.groupId;
  cluster = other80.cluster;
  offsets = other80.offsets;
}
AckResult& AckResult::operator=(const AckResult& other81) {
  consumerId = other81.consumerId;
  groupId = other81.groupId;
  cluster = other81.cluster;
  offsets = other81.offsets;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AckResult& obj) {
  using apache::thrift::to_string;
  out << "AckResult(";
  out << "consumerId=" << to_string(obj.consumerId);
  out << ", " << "groupId=" << to_string(obj.groupId);
  out << ", " << "cluster=" << to_string(obj.cluster);
  out << ", " << "offsets=" << to_string(obj.offsets);
  out << ")";
  return out;
}


ConsumeStats::~ConsumeStats() throw() {
}


void ConsumeStats::__set_group(const std::string& val) {
  this->group = val;
}

void ConsumeStats::__set_topic(const std::string& val) {
  this->topic = val;
}

void ConsumeStats::__set_consumeOffsets(const std::map<std::string, int64_t> & val) {
  this->consumeOffsets = val;
}

void ConsumeStats::__set_produceOffsets(const std::map<std::string, int64_t> & val) {
  this->produceOffsets = val;
}

const char* ConsumeStats::ascii_fingerprint = "8D9F5B5937A1540513F1581F5CBEB4BE";
const uint8_t ConsumeStats::binary_fingerprint[16] = {0x8D,0x9F,0x5B,0x59,0x37,0xA1,0x54,0x05,0x13,0xF1,0x58,0x1F,0x5C,0xBE,0xB4,0xBE};

uint32_t ConsumeStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->consumeOffsets.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readString(_key87);
              int64_t& _val88 = this->consumeOffsets[_key87];
              xfer += iprot->readI64(_val88);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.consumeOffsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->produceOffsets.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _ktype90;
            ::apache::thrift::protocol::TType _vtype91;
            xfer += iprot->readMapBegin(_ktype90, _vtype91, _size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              std::string _key94;
              xfer += iprot->readString(_key94);
              int64_t& _val95 = this->produceOffsets[_key94];
              xfer += iprot->readI64(_val95);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.produceOffsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumeStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ConsumeStats");

  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("consumeOffsets", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->consumeOffsets.size()));
    std::map<std::string, int64_t> ::const_iterator _iter96;
    for (_iter96 = this->consumeOffsets.begin(); _iter96 != this->consumeOffsets.end(); ++_iter96)
    {
      xfer += oprot->writeString(_iter96->first);
      xfer += oprot->writeI64(_iter96->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("produceOffsets", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->produceOffsets.size()));
    std::map<std::string, int64_t> ::const_iterator _iter97;
    for (_iter97 = this->produceOffsets.begin(); _iter97 != this->produceOffsets.end(); ++_iter97)
    {
      xfer += oprot->writeString(_iter97->first);
      xfer += oprot->writeI64(_iter97->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ConsumeStats &a, ConsumeStats &b) {
  using ::std::swap;
  swap(a.group, b.group);
  swap(a.topic, b.topic);
  swap(a.consumeOffsets, b.consumeOffsets);
  swap(a.produceOffsets, b.produceOffsets);
  swap(a.__isset, b.__isset);
}

ConsumeStats::ConsumeStats(const ConsumeStats& other98) {
  group = other98.group;
  topic = other98.topic;
  consumeOffsets = other98.consumeOffsets;
  produceOffsets = other98.produceOffsets;
  __isset = other98.__isset;
}
ConsumeStats& ConsumeStats::operator=(const ConsumeStats& other99) {
  group = other99.group;
  topic = other99.topic;
  consumeOffsets = other99.consumeOffsets;
  produceOffsets = other99.produceOffsets;
  __isset = other99.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ConsumeStats& obj) {
  using apache::thrift::to_string;
  out << "ConsumeStats(";
  out << "group=" << to_string(obj.group);
  out << ", " << "topic=" << to_string(obj.topic);
  out << ", " << "consumeOffsets=" << to_string(obj.consumeOffsets);
  out << ", " << "produceOffsets=" << to_string(obj.produceOffsets);
  out << ")";
  return out;
}


PullException::~PullException() throw() {
}


void PullException::__set_code(const int32_t val) {
  this->code = val;
}

void PullException::__set_message(const std::string& val) {
  this->message = val;
}

const char* PullException::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t PullException::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t PullException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PullException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PullException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PullException &a, PullException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

PullException::PullException(const PullException& other100) : TException() {
  code = other100.code;
  message = other100.message;
  __isset = other100.__isset;
}
PullException& PullException::operator=(const PullException& other101) {
  code = other101.code;
  message = other101.message;
  __isset = other101.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PullException& obj) {
  using apache::thrift::to_string;
  out << "PullException(";
  out << "code=" << to_string(obj.code);
  out << ", " << "message=" << to_string(obj.message);
  out << ")";
  return out;
}

} // namespace
