/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef carreraServiceDiscovery_TYPES_H
#define carreraServiceDiscovery_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace CarreraServiceDiscovery {

class Endpoint;

class ClusterMeta;

class ConfigValue;

class ServiceMeta;

class ClientMeta;

typedef struct _Endpoint__isset {
  _Endpoint__isset() : ip(false), port(false) {}
  bool ip :1;
  bool port :1;
} _Endpoint__isset;

class Endpoint {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  Endpoint(const Endpoint&);
  Endpoint& operator=(const Endpoint&);
  Endpoint() : ip(), port(0) {
  }

  virtual ~Endpoint() throw();
  std::string ip;
  int32_t port;

  _Endpoint__isset __isset;

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const Endpoint & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const Endpoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Endpoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Endpoint& obj);
};

void swap(Endpoint &a, Endpoint &b);

typedef struct _ClusterMeta__isset {
  _ClusterMeta__isset() : idc(false), clusterName(false), endpoints(false) {}
  bool idc :1;
  bool clusterName :1;
  bool endpoints :1;
} _ClusterMeta__isset;

class ClusterMeta {
 public:

  static const char* ascii_fingerprint; // = "12A8B9C13CB72040CC5B51A362762286";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0xA8,0xB9,0xC1,0x3C,0xB7,0x20,0x40,0xCC,0x5B,0x51,0xA3,0x62,0x76,0x22,0x86};

  ClusterMeta(const ClusterMeta&);
  ClusterMeta& operator=(const ClusterMeta&);
  ClusterMeta() : idc(), clusterName() {
  }

  virtual ~ClusterMeta() throw();
  std::string idc;
  std::string clusterName;
  std::vector<Endpoint>  endpoints;

  _ClusterMeta__isset __isset;

  void __set_idc(const std::string& val);

  void __set_clusterName(const std::string& val);

  void __set_endpoints(const std::vector<Endpoint> & val);

  bool operator == (const ClusterMeta & rhs) const
  {
    if (!(idc == rhs.idc))
      return false;
    if (!(clusterName == rhs.clusterName))
      return false;
    if (!(endpoints == rhs.endpoints))
      return false;
    return true;
  }
  bool operator != (const ClusterMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ClusterMeta& obj);
};

void swap(ClusterMeta &a, ClusterMeta &b);

typedef struct _ConfigValue__isset {
  _ConfigValue__isset() : userDefined(false), value(false) {}
  bool userDefined :1;
  bool value :1;
} _ConfigValue__isset;

class ConfigValue {
 public:

  static const char* ascii_fingerprint; // = "1767FFB0CB3D9275BC64B198AB3B8A8B";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

  ConfigValue(const ConfigValue&);
  ConfigValue& operator=(const ConfigValue&);
  ConfigValue() : userDefined(0), value() {
  }

  virtual ~ConfigValue() throw();
  bool userDefined;
  std::string value;

  _ConfigValue__isset __isset;

  void __set_userDefined(const bool val);

  void __set_value(const std::string& val);

  bool operator == (const ConfigValue & rhs) const
  {
    if (!(userDefined == rhs.userDefined))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ConfigValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConfigValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ConfigValue& obj);
};

void swap(ConfigValue &a, ConfigValue &b);

typedef struct _ServiceMeta__isset {
  _ServiceMeta__isset() : metaVersion(false), metaHash(false), metaList(false), config(false) {}
  bool metaVersion :1;
  bool metaHash :1;
  bool metaList :1;
  bool config :1;
} _ServiceMeta__isset;

class ServiceMeta {
 public:

  static const char* ascii_fingerprint; // = "3715871E09BDC3F4E66F9AE2A3E616E3";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x15,0x87,0x1E,0x09,0xBD,0xC3,0xF4,0xE6,0x6F,0x9A,0xE2,0xA3,0xE6,0x16,0xE3};

  ServiceMeta(const ServiceMeta&);
  ServiceMeta& operator=(const ServiceMeta&);
  ServiceMeta() : metaVersion(0), metaHash() {
  }

  virtual ~ServiceMeta() throw();
  int64_t metaVersion;
  std::string metaHash;
  std::vector<ClusterMeta>  metaList;
  std::map<std::string, std::string>  config;

  _ServiceMeta__isset __isset;

  void __set_metaVersion(const int64_t val);

  void __set_metaHash(const std::string& val);

  void __set_metaList(const std::vector<ClusterMeta> & val);

  void __set_config(const std::map<std::string, std::string> & val);  

  bool operator == (const ServiceMeta & rhs) const
  {
    if (!(metaVersion == rhs.metaVersion))
      return false;
    if (!(metaHash == rhs.metaHash))
      return false;
    if (!(metaList == rhs.metaList))
      return false;
    if (__isset.config != rhs.__isset.config)
      return false;
    else if (__isset.config && !(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const ServiceMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServiceMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ServiceMeta& obj);
};

void swap(ServiceMeta &a, ServiceMeta &b);

typedef struct _ClientMeta__isset {
  _ClientMeta__isset() : idc(false), version(false), clientId(false), config(false) {}
  bool idc :1;
  bool version :1;
  bool clientId :1;
  bool config :1;
} _ClientMeta__isset;

class ClientMeta {
 public:

  static const char* ascii_fingerprint; // = "7430B7012C109788A0D23F31C92B3C25";
  static const uint8_t binary_fingerprint[16]; // = {0x74,0x30,0xB7,0x01,0x2C,0x10,0x97,0x88,0xA0,0xD2,0x3F,0x31,0xC9,0x2B,0x3C,0x25};

  ClientMeta(const ClientMeta&);
  ClientMeta& operator=(const ClientMeta&);
  ClientMeta() : idc(), version(), clientId() {
  }

  virtual ~ClientMeta() throw();
  std::string idc;
  std::string version;
  std::string clientId;
  std::map<std::string, ConfigValue>  config;

  _ClientMeta__isset __isset;

  void __set_idc(const std::string& val);

  void __set_version(const std::string& val);

  void __set_clientId(const std::string& val);

  void __set_config(const std::map<std::string, ConfigValue> & val);

  bool operator == (const ClientMeta & rhs) const
  {
    if (!(idc == rhs.idc))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(clientId == rhs.clientId))
      return false;
    if (__isset.config != rhs.__isset.config)
      return false;
    else if (__isset.config && !(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const ClientMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ClientMeta& obj);
};

void swap(ClientMeta &a, ClientMeta &b);

} // namespace

#endif
