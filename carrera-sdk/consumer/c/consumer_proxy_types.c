/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "consumer_proxy_types.h"
#include <thrift/c_glib/thrift.h>

enum _MessageProperties
{
  PROP_MESSAGE_0,
  PROP_MESSAGE_KEY,
  PROP_MESSAGE_VALUE,
  PROP_MESSAGE_TAG,
  PROP_MESSAGE_OFFSET
};

/* reads a message object */
static gint32
message_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Message * this_object = MESSAGE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->tag != NULL)
          {
            g_free(this_object->tag);
            this_object->tag = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
message_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Message * this_object = MESSAGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Message", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->value)->data, ((GByteArray *) this_object->value)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tag, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
message_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Message *self = MESSAGE (object);

  switch (property_id)
  {
    case PROP_MESSAGE_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_MESSAGE_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_MESSAGE_TAG:
      if (self->tag != NULL)
        g_free (self->tag);
      self->tag = g_value_dup_string (value);
      self->__isset_tag = TRUE;
      break;

    case PROP_MESSAGE_OFFSET:
      self->offset = g_value_get_int64 (value);
      self->__isset_offset = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
message_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Message *self = MESSAGE (object);

  switch (property_id)
  {
    case PROP_MESSAGE_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_MESSAGE_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_MESSAGE_TAG:
      g_value_set_string (value, self->tag);
      break;

    case PROP_MESSAGE_OFFSET:
      g_value_set_int64 (value, self->offset);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
message_instance_init (Message * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->tag = NULL;
  object->__isset_tag = FALSE;
  object->offset = 0;
  object->__isset_offset = FALSE;
}

static void 
message_finalize (GObject *object)
{
  Message *tobject = MESSAGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->tag != NULL)
  {
    g_free(tobject->tag);
    tobject->tag = NULL;
  }
}

static void
message_class_init (MessageClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = message_read;
  struct_class->write = message_write;

  gobject_class->finalize = message_finalize;
  gobject_class->get_property = message_get_property;
  gobject_class->set_property = message_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MESSAGE_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MESSAGE_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MESSAGE_TAG,
     g_param_spec_string ("tag",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MESSAGE_OFFSET,
     g_param_spec_int64 ("offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
message_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MessageClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) message_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Message),
      0, /* n_preallocs */
      (GInstanceInitFunc) message_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MessageType",
                                   &type_info, 0);
  }

  return type;
}

enum _ContextProperties
{
  PROP_CONTEXT_0,
  PROP_CONTEXT_GROUP_ID,
  PROP_CONTEXT_TOPIC,
  PROP_CONTEXT_QID
};

/* reads a context object */
static gint32
context_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Context * this_object = CONTEXT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->groupId != NULL)
          {
            g_free(this_object->groupId);
            this_object->groupId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->qid != NULL)
          {
            g_free(this_object->qid);
            this_object->qid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->qid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_qid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
context_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Context * this_object = CONTEXT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Context", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->groupId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qid", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->qid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
context_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Context *self = CONTEXT (object);

  switch (property_id)
  {
    case PROP_CONTEXT_GROUP_ID:
      if (self->groupId != NULL)
        g_free (self->groupId);
      self->groupId = g_value_dup_string (value);
      self->__isset_groupId = TRUE;
      break;

    case PROP_CONTEXT_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      self->__isset_topic = TRUE;
      break;

    case PROP_CONTEXT_QID:
      if (self->qid != NULL)
        g_free (self->qid);
      self->qid = g_value_dup_string (value);
      self->__isset_qid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
context_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Context *self = CONTEXT (object);

  switch (property_id)
  {
    case PROP_CONTEXT_GROUP_ID:
      g_value_set_string (value, self->groupId);
      break;

    case PROP_CONTEXT_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_CONTEXT_QID:
      g_value_set_string (value, self->qid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
context_instance_init (Context * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->groupId = NULL;
  object->__isset_groupId = FALSE;
  object->topic = NULL;
  object->__isset_topic = FALSE;
  object->qid = NULL;
  object->__isset_qid = FALSE;
}

static void 
context_finalize (GObject *object)
{
  Context *tobject = CONTEXT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->groupId != NULL)
  {
    g_free(tobject->groupId);
    tobject->groupId = NULL;
  }
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->qid != NULL)
  {
    g_free(tobject->qid);
    tobject->qid = NULL;
  }
}

static void
context_class_init (ContextClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = context_read;
  struct_class->write = context_write;

  gobject_class->finalize = context_finalize;
  gobject_class->get_property = context_get_property;
  gobject_class->set_property = context_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONTEXT_GROUP_ID,
     g_param_spec_string ("groupId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONTEXT_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONTEXT_QID,
     g_param_spec_string ("qid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
context_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ContextClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) context_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Context),
      0, /* n_preallocs */
      (GInstanceInitFunc) context_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ContextType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumeResultProperties
{
  PROP_CONSUME_RESULT_0,
  PROP_CONSUME_RESULT_CONTEXT,
  PROP_CONSUME_RESULT_SUCCESS_OFFSETS,
  PROP_CONSUME_RESULT_FAIL_OFFSETS,
  PROP_CONSUME_RESULT_NEXT_RESULT
};

/* reads a consume_result object */
static gint32
consume_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumeResult * this_object = CONSUME_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->context), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_context = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint64* _elem0 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->successOffsets, _elem0, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_successOffsets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gint64* _elem1 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem1, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->failOffsets, _elem1, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_failOffsets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->nextResult), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_nextResult = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consume_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumeResult * this_object = CONSUME_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumeResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "context", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->context), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "successOffsets", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->successOffsets->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i2;
    for (i2=0; i2<this_object->successOffsets->len; i2++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->successOffsets, gint64, i2)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "failOffsets", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->failOffsets->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i3;
    for (i3=0; i3<this_object->failOffsets->len; i3++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->failOffsets, gint64, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_nextResult == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "nextResult", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->nextResult), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consume_result_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  ConsumeResult *self = CONSUME_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUME_RESULT_CONTEXT:
      if (self->context != NULL)
        g_object_unref (self->context);
      self->context = g_value_dup_object (value);
      self->__isset_context = TRUE;
      break;

    case PROP_CONSUME_RESULT_SUCCESS_OFFSETS:
      if (self->successOffsets != NULL)
        g_array_unref (self->successOffsets);
      self->successOffsets = g_value_dup_boxed (value);
      self->__isset_successOffsets = TRUE;
      break;

    case PROP_CONSUME_RESULT_FAIL_OFFSETS:
      if (self->failOffsets != NULL)
        g_array_unref (self->failOffsets);
      self->failOffsets = g_value_dup_boxed (value);
      self->__isset_failOffsets = TRUE;
      break;

    case PROP_CONSUME_RESULT_NEXT_RESULT:
      if (self->nextResult != NULL)
        g_object_unref (self->nextResult);
      self->nextResult = g_value_dup_object (value);
      self->__isset_nextResult = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consume_result_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  ConsumeResult *self = CONSUME_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUME_RESULT_CONTEXT:
      g_value_set_object (value, self->context);
      break;

    case PROP_CONSUME_RESULT_SUCCESS_OFFSETS:
      g_value_set_boxed (value, self->successOffsets);
      break;

    case PROP_CONSUME_RESULT_FAIL_OFFSETS:
      g_value_set_boxed (value, self->failOffsets);
      break;

    case PROP_CONSUME_RESULT_NEXT_RESULT:
      g_value_set_object (value, self->nextResult);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consume_result_instance_init (ConsumeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->context = g_object_new (TYPE_CONTEXT, NULL);
  object->__isset_context = FALSE;
  object->successOffsets = g_array_new (0, 1, sizeof (gint64));
  object->__isset_successOffsets = FALSE;
  object->failOffsets = g_array_new (0, 1, sizeof (gint64));
  object->__isset_failOffsets = FALSE;
  object->nextResult = g_object_new (TYPE_CONSUME_RESULT, NULL);
  object->__isset_nextResult = FALSE;
}

static void 
consume_result_finalize (GObject *object)
{
  ConsumeResult *tobject = CONSUME_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->context != NULL)
  {
    g_object_unref(tobject->context);
    tobject->context = NULL;
  }
  if (tobject->successOffsets != NULL)
  {
    g_array_unref (tobject->successOffsets);
    tobject->successOffsets = NULL;
  }
  if (tobject->failOffsets != NULL)
  {
    g_array_unref (tobject->failOffsets);
    tobject->failOffsets = NULL;
  }
  if (tobject->nextResult != NULL)
  {
    g_object_unref(tobject->nextResult);
    tobject->nextResult = NULL;
  }
}

static void
consume_result_class_init (ConsumeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consume_result_read;
  struct_class->write = consume_result_write;

  gobject_class->finalize = consume_result_finalize;
  gobject_class->get_property = consume_result_get_property;
  gobject_class->set_property = consume_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_RESULT_CONTEXT,
     g_param_spec_object ("context",
                         NULL,
                         NULL,
                         TYPE_CONTEXT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_RESULT_SUCCESS_OFFSETS,
     g_param_spec_boxed ("successOffsets",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_RESULT_FAIL_OFFSETS,
     g_param_spec_boxed ("failOffsets",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_RESULT_NEXT_RESULT,
     g_param_spec_object ("nextResult",
                         NULL,
                         NULL,
                         TYPE_CONSUME_RESULT,
                         G_PARAM_READWRITE));
}

GType
consume_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consume_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consume_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _PullRequestProperties
{
  PROP_PULL_REQUEST_0,
  PROP_PULL_REQUEST_GROUP_ID,
  PROP_PULL_REQUEST_TOPIC,
  PROP_PULL_REQUEST_MAX_BATCH_SIZE,
  PROP_PULL_REQUEST_MAX_LINGER_TIME,
  PROP_PULL_REQUEST_RESULT,
  PROP_PULL_REQUEST_VERSION
};

/* reads a pull_request object */
static gint32
pull_request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PullRequest * this_object = PULL_REQUEST(object);
  gboolean isset_groupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->groupId != NULL)
          {
            g_free(this_object->groupId);
            this_object->groupId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxBatchSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxBatchSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxLingerTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxLingerTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 50:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_result = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 60:
        if (ftype == T_STRING)
        {
          if (this_object->version != NULL)
          {
            g_free(this_object->version);
            this_object->version = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_groupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
pull_request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PullRequest * this_object = PULL_REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PullRequest", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->groupId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_topic == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxBatchSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxBatchSize", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxBatchSize, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxLingerTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxLingerTime", T_I32, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxLingerTime, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_result == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "result", T_STRUCT, 50, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRING, 60, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->version, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
pull_request_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  PullRequest *self = PULL_REQUEST (object);

  switch (property_id)
  {
    case PROP_PULL_REQUEST_GROUP_ID:
      if (self->groupId != NULL)
        g_free (self->groupId);
      self->groupId = g_value_dup_string (value);
      break;

    case PROP_PULL_REQUEST_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      self->__isset_topic = TRUE;
      break;

    case PROP_PULL_REQUEST_MAX_BATCH_SIZE:
      self->maxBatchSize = g_value_get_int (value);
      self->__isset_maxBatchSize = TRUE;
      break;

    case PROP_PULL_REQUEST_MAX_LINGER_TIME:
      self->maxLingerTime = g_value_get_int (value);
      self->__isset_maxLingerTime = TRUE;
      break;

    case PROP_PULL_REQUEST_RESULT:
      if (self->result != NULL)
        g_object_unref (self->result);
      self->result = g_value_dup_object (value);
      self->__isset_result = TRUE;
      break;

    case PROP_PULL_REQUEST_VERSION:
      if (self->version != NULL)
        g_free (self->version);
      self->version = g_value_dup_string (value);
      self->__isset_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
pull_request_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  PullRequest *self = PULL_REQUEST (object);

  switch (property_id)
  {
    case PROP_PULL_REQUEST_GROUP_ID:
      g_value_set_string (value, self->groupId);
      break;

    case PROP_PULL_REQUEST_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_PULL_REQUEST_MAX_BATCH_SIZE:
      g_value_set_int (value, self->maxBatchSize);
      break;

    case PROP_PULL_REQUEST_MAX_LINGER_TIME:
      g_value_set_int (value, self->maxLingerTime);
      break;

    case PROP_PULL_REQUEST_RESULT:
      g_value_set_object (value, self->result);
      break;

    case PROP_PULL_REQUEST_VERSION:
      g_value_set_string (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
pull_request_instance_init (PullRequest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->groupId = NULL;
  object->topic = NULL;
  object->__isset_topic = FALSE;
  object->maxBatchSize = 0;
  object->__isset_maxBatchSize = FALSE;
  object->maxLingerTime = 0;
  object->__isset_maxLingerTime = FALSE;
  object->result = g_object_new (TYPE_CONSUME_RESULT, NULL);
  object->__isset_result = FALSE;
  object->version = NULL;
  object->__isset_version = FALSE;
}

static void 
pull_request_finalize (GObject *object)
{
  PullRequest *tobject = PULL_REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->groupId != NULL)
  {
    g_free(tobject->groupId);
    tobject->groupId = NULL;
  }
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->result != NULL)
  {
    g_object_unref(tobject->result);
    tobject->result = NULL;
  }
  if (tobject->version != NULL)
  {
    g_free(tobject->version);
    tobject->version = NULL;
  }
}

static void
pull_request_class_init (PullRequestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = pull_request_read;
  struct_class->write = pull_request_write;

  gobject_class->finalize = pull_request_finalize;
  gobject_class->get_property = pull_request_get_property;
  gobject_class->set_property = pull_request_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_GROUP_ID,
     g_param_spec_string ("groupId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_MAX_BATCH_SIZE,
     g_param_spec_int ("maxBatchSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_MAX_LINGER_TIME,
     g_param_spec_int ("maxLingerTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_RESULT,
     g_param_spec_object ("result",
                         NULL,
                         NULL,
                         TYPE_CONSUME_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_REQUEST_VERSION,
     g_param_spec_string ("version",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
pull_request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PullRequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) pull_request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PullRequest),
      0, /* n_preallocs */
      (GInstanceInitFunc) pull_request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PullRequestType",
                                   &type_info, 0);
  }

  return type;
}

enum _PullResponseProperties
{
  PROP_PULL_RESPONSE_0,
  PROP_PULL_RESPONSE_CONTEXT,
  PROP_PULL_RESPONSE_MESSAGES
};

/* reads a pull_response object */
static gint32
pull_response_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PullResponse * this_object = PULL_RESPONSE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->context), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_context = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              Message * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_MESSAGE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->messages, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_messages = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
pull_response_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PullResponse * this_object = PULL_RESPONSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PullResponse", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "context", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->context), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "messages", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->messages->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i5;
    for (i5=0; i5<this_object->messages->len; i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->messages, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
pull_response_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  PullResponse *self = PULL_RESPONSE (object);

  switch (property_id)
  {
    case PROP_PULL_RESPONSE_CONTEXT:
      if (self->context != NULL)
        g_object_unref (self->context);
      self->context = g_value_dup_object (value);
      self->__isset_context = TRUE;
      break;

    case PROP_PULL_RESPONSE_MESSAGES:
      if (self->messages != NULL)
        g_ptr_array_unref (self->messages);
      self->messages = g_value_dup_boxed (value);
      self->__isset_messages = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
pull_response_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  PullResponse *self = PULL_RESPONSE (object);

  switch (property_id)
  {
    case PROP_PULL_RESPONSE_CONTEXT:
      g_value_set_object (value, self->context);
      break;

    case PROP_PULL_RESPONSE_MESSAGES:
      g_value_set_boxed (value, self->messages);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
pull_response_instance_init (PullResponse * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->context = g_object_new (TYPE_CONTEXT, NULL);
  object->__isset_context = FALSE;
  object->messages = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_messages = FALSE;
}

static void 
pull_response_finalize (GObject *object)
{
  PullResponse *tobject = PULL_RESPONSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->context != NULL)
  {
    g_object_unref(tobject->context);
    tobject->context = NULL;
  }
  if (tobject->messages != NULL)
  {
    g_ptr_array_unref (tobject->messages);
    tobject->messages = NULL;
  }
}

static void
pull_response_class_init (PullResponseClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = pull_response_read;
  struct_class->write = pull_response_write;

  gobject_class->finalize = pull_response_finalize;
  gobject_class->get_property = pull_response_get_property;
  gobject_class->set_property = pull_response_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_RESPONSE_CONTEXT,
     g_param_spec_object ("context",
                         NULL,
                         NULL,
                         TYPE_CONTEXT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_RESPONSE_MESSAGES,
     g_param_spec_boxed ("messages",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
pull_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PullResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) pull_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PullResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc) pull_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PullResponseType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumeStatsRequestProperties
{
  PROP_CONSUME_STATS_REQUEST_0,
  PROP_CONSUME_STATS_REQUEST_GROUP,
  PROP_CONSUME_STATS_REQUEST_TOPIC,
  PROP_CONSUME_STATS_REQUEST_VERSION
};

/* reads a consume_stats_request object */
static gint32
consume_stats_request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumeStatsRequest * this_object = CONSUME_STATS_REQUEST(object);
  gboolean isset_group = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->group != NULL)
          {
            g_free(this_object->group);
            this_object->group = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->group, error)) < 0)
            return -1;
          xfer += ret;
          isset_group = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->version != NULL)
          {
            g_free(this_object->version);
            this_object->version = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_group)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
consume_stats_request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumeStatsRequest * this_object = CONSUME_STATS_REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumeStatsRequest", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "group", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->group, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_topic == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->version, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consume_stats_request_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ConsumeStatsRequest *self = CONSUME_STATS_REQUEST (object);

  switch (property_id)
  {
    case PROP_CONSUME_STATS_REQUEST_GROUP:
      if (self->group != NULL)
        g_free (self->group);
      self->group = g_value_dup_string (value);
      break;

    case PROP_CONSUME_STATS_REQUEST_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      self->__isset_topic = TRUE;
      break;

    case PROP_CONSUME_STATS_REQUEST_VERSION:
      if (self->version != NULL)
        g_free (self->version);
      self->version = g_value_dup_string (value);
      self->__isset_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consume_stats_request_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ConsumeStatsRequest *self = CONSUME_STATS_REQUEST (object);

  switch (property_id)
  {
    case PROP_CONSUME_STATS_REQUEST_GROUP:
      g_value_set_string (value, self->group);
      break;

    case PROP_CONSUME_STATS_REQUEST_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_CONSUME_STATS_REQUEST_VERSION:
      g_value_set_string (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consume_stats_request_instance_init (ConsumeStatsRequest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->group = NULL;
  object->topic = NULL;
  object->__isset_topic = FALSE;
  object->version = NULL;
  object->__isset_version = FALSE;
}

static void 
consume_stats_request_finalize (GObject *object)
{
  ConsumeStatsRequest *tobject = CONSUME_STATS_REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->group != NULL)
  {
    g_free(tobject->group);
    tobject->group = NULL;
  }
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->version != NULL)
  {
    g_free(tobject->version);
    tobject->version = NULL;
  }
}

static void
consume_stats_request_class_init (ConsumeStatsRequestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consume_stats_request_read;
  struct_class->write = consume_stats_request_write;

  gobject_class->finalize = consume_stats_request_finalize;
  gobject_class->get_property = consume_stats_request_get_property;
  gobject_class->set_property = consume_stats_request_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_REQUEST_GROUP,
     g_param_spec_string ("group",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_REQUEST_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_REQUEST_VERSION,
     g_param_spec_string ("version",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
consume_stats_request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumeStatsRequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consume_stats_request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumeStatsRequest),
      0, /* n_preallocs */
      (GInstanceInitFunc) consume_stats_request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumeStatsRequestType",
                                   &type_info, 0);
  }

  return type;
}

enum _FetchRequestProperties
{
  PROP_FETCH_REQUEST_0,
  PROP_FETCH_REQUEST_CONSUMER_ID,
  PROP_FETCH_REQUEST_GROUP_ID,
  PROP_FETCH_REQUEST_CLUSTER,
  PROP_FETCH_REQUEST_FETCH_OFFSET,
  PROP_FETCH_REQUEST_MAX_BATCH_SIZE,
  PROP_FETCH_REQUEST_MAX_LINGER_TIME,
  PROP_FETCH_REQUEST_VERSION
};

/* reads a fetch_request object */
static gint32
fetch_request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FetchRequest * this_object = FETCH_REQUEST(object);
  gboolean isset_consumerId = FALSE;
  gboolean isset_groupId = FALSE;
  gboolean isset_cluster = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->consumerId != NULL)
          {
            g_free(this_object->consumerId);
            this_object->consumerId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->consumerId, error)) < 0)
            return -1;
          xfer += ret;
          isset_consumerId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->groupId != NULL)
          {
            g_free(this_object->groupId);
            this_object->groupId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->cluster != NULL)
          {
            g_free(this_object->cluster);
            this_object->cluster = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cluster, error)) < 0)
            return -1;
          xfer += ret;
          isset_cluster = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key6 = NULL;
              GHashTable * val7 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
              if (key6 != NULL)
              {
                g_free(key6);
                key6 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key6, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gchar * key8 = NULL;
                  gint64* val9 = g_new (gint64, 1);
                  if (key8 != NULL)
                  {
                    g_free(key8);
                    key8 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &key8, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_i64 (protocol, &*val9, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val7, (gpointer) key8, (gpointer) val9);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->fetchOffset, (gpointer) key6, (gpointer) val7);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_fetchOffset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxBatchSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxBatchSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxLingerTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxLingerTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 60:
        if (ftype == T_STRING)
        {
          if (this_object->version != NULL)
          {
            g_free(this_object->version);
            this_object->version = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_consumerId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_groupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_cluster)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
fetch_request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FetchRequest * this_object = FETCH_REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FetchRequest", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "consumerId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->consumerId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->groupId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cluster", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->cluster, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_fetchOffset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fetchOffset", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->fetchOffset), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key10 = NULL;
      GHashTable * val11 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
      g_hash_table_foreach ((GHashTable *) this_object->fetchOffset, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key10 = keys[i];
        val11 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->fetchOffset), (gpointer) key10);

        if ((ret = thrift_protocol_write_string (protocol,  key10, error)) < 0)
          return -1;
        {
          if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I64, (gint32) g_hash_table_size ((GHashTable *)  val11), error)) < 0)
            return -1;
          xfer += ret;

          GList *key_list = NULL, *iter = NULL;
          gchar * key12 = NULL;
          gint64* val13 = g_new (gint64, 1);
          g_hash_table_foreach ((GHashTable *)  val11, thrift_hash_table_get_keys, &key_list);
          gchar * keys[g_list_length (key_list)];
          int i=0, key_count = g_list_length (key_list);
          for (iter = g_list_first (key_list); iter; iter = iter->next)
          {
            keys[i++] = (gchar *) iter->data;
          }
          g_list_free (key_list);

          for (i = 0; i < key_count; ++i)
          {
            key12 = keys[i];
            val13 = (gint64*) g_hash_table_lookup (((GHashTable *)  val11), (gpointer) key12);

            if ((ret = thrift_protocol_write_string (protocol,  key12, error)) < 0)
              return -1;
            if ((ret = thrift_protocol_write_i64 (protocol, * val13, error)) < 0)
              return -1;
          }
          if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxBatchSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxBatchSize", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxBatchSize, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxLingerTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxLingerTime", T_I32, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxLingerTime, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRING, 60, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->version, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
fetch_request_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  FetchRequest *self = FETCH_REQUEST (object);

  switch (property_id)
  {
    case PROP_FETCH_REQUEST_CONSUMER_ID:
      if (self->consumerId != NULL)
        g_free (self->consumerId);
      self->consumerId = g_value_dup_string (value);
      break;

    case PROP_FETCH_REQUEST_GROUP_ID:
      if (self->groupId != NULL)
        g_free (self->groupId);
      self->groupId = g_value_dup_string (value);
      break;

    case PROP_FETCH_REQUEST_CLUSTER:
      if (self->cluster != NULL)
        g_free (self->cluster);
      self->cluster = g_value_dup_string (value);
      break;

    case PROP_FETCH_REQUEST_FETCH_OFFSET:
      if (self->fetchOffset != NULL)
        g_hash_table_unref (self->fetchOffset);
      self->fetchOffset = g_value_dup_boxed (value);
      self->__isset_fetchOffset = TRUE;
      break;

    case PROP_FETCH_REQUEST_MAX_BATCH_SIZE:
      self->maxBatchSize = g_value_get_int (value);
      self->__isset_maxBatchSize = TRUE;
      break;

    case PROP_FETCH_REQUEST_MAX_LINGER_TIME:
      self->maxLingerTime = g_value_get_int (value);
      self->__isset_maxLingerTime = TRUE;
      break;

    case PROP_FETCH_REQUEST_VERSION:
      if (self->version != NULL)
        g_free (self->version);
      self->version = g_value_dup_string (value);
      self->__isset_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
fetch_request_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  FetchRequest *self = FETCH_REQUEST (object);

  switch (property_id)
  {
    case PROP_FETCH_REQUEST_CONSUMER_ID:
      g_value_set_string (value, self->consumerId);
      break;

    case PROP_FETCH_REQUEST_GROUP_ID:
      g_value_set_string (value, self->groupId);
      break;

    case PROP_FETCH_REQUEST_CLUSTER:
      g_value_set_string (value, self->cluster);
      break;

    case PROP_FETCH_REQUEST_FETCH_OFFSET:
      g_value_set_boxed (value, self->fetchOffset);
      break;

    case PROP_FETCH_REQUEST_MAX_BATCH_SIZE:
      g_value_set_int (value, self->maxBatchSize);
      break;

    case PROP_FETCH_REQUEST_MAX_LINGER_TIME:
      g_value_set_int (value, self->maxLingerTime);
      break;

    case PROP_FETCH_REQUEST_VERSION:
      g_value_set_string (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
fetch_request_instance_init (FetchRequest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->consumerId = NULL;
  object->groupId = NULL;
  object->cluster = NULL;
  object->fetchOffset = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
  object->__isset_fetchOffset = FALSE;
  object->maxBatchSize = 0;
  object->__isset_maxBatchSize = FALSE;
  object->maxLingerTime = 0;
  object->__isset_maxLingerTime = FALSE;
  object->version = NULL;
  object->__isset_version = FALSE;
}

static void 
fetch_request_finalize (GObject *object)
{
  FetchRequest *tobject = FETCH_REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->consumerId != NULL)
  {
    g_free(tobject->consumerId);
    tobject->consumerId = NULL;
  }
  if (tobject->groupId != NULL)
  {
    g_free(tobject->groupId);
    tobject->groupId = NULL;
  }
  if (tobject->cluster != NULL)
  {
    g_free(tobject->cluster);
    tobject->cluster = NULL;
  }
  if (tobject->fetchOffset != NULL)
  {
    g_hash_table_destroy (tobject->fetchOffset);
    tobject->fetchOffset = NULL;
  }
  if (tobject->version != NULL)
  {
    g_free(tobject->version);
    tobject->version = NULL;
  }
}

static void
fetch_request_class_init (FetchRequestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = fetch_request_read;
  struct_class->write = fetch_request_write;

  gobject_class->finalize = fetch_request_finalize;
  gobject_class->get_property = fetch_request_get_property;
  gobject_class->set_property = fetch_request_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_CONSUMER_ID,
     g_param_spec_string ("consumerId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_GROUP_ID,
     g_param_spec_string ("groupId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_CLUSTER,
     g_param_spec_string ("cluster",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_FETCH_OFFSET,
     g_param_spec_boxed ("fetchOffset",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_MAX_BATCH_SIZE,
     g_param_spec_int ("maxBatchSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_MAX_LINGER_TIME,
     g_param_spec_int ("maxLingerTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_REQUEST_VERSION,
     g_param_spec_string ("version",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
fetch_request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FetchRequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) fetch_request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FetchRequest),
      0, /* n_preallocs */
      (GInstanceInitFunc) fetch_request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FetchRequestType",
                                   &type_info, 0);
  }

  return type;
}

enum _QidResponseProperties
{
  PROP_QID_RESPONSE_0,
  PROP_QID_RESPONSE_TOPIC,
  PROP_QID_RESPONSE_QID,
  PROP_QID_RESPONSE_NEXT_REQUEST_OFFSET,
  PROP_QID_RESPONSE_MESSAGES
};

/* reads a qid_response object */
static gint32
qid_response_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  QidResponse * this_object = QID_RESPONSE(object);
  gboolean isset_topic = FALSE;
  gboolean isset_qid = FALSE;
  gboolean isset_messages = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->qid != NULL)
          {
            g_free(this_object->qid);
            this_object->qid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->qid, error)) < 0)
            return -1;
          xfer += ret;
          isset_qid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->nextRequestOffset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nextRequestOffset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              Message * _elem14 = NULL;
              if ( _elem14 != NULL)
              {
                g_object_unref (_elem14);
              }
              _elem14 = g_object_new (TYPE_MESSAGE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
              {
                g_object_unref (_elem14);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->messages, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_messages = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_topic)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_messages)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
qid_response_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  QidResponse * this_object = QID_RESPONSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "QidResponse", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->qid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_nextRequestOffset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "nextRequestOffset", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->nextRequestOffset, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "messages", T_LIST, 10, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->messages->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i15;
    for (i15=0; i15<this_object->messages->len; i15++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->messages, i15))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
qid_response_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  QidResponse *self = QID_RESPONSE (object);

  switch (property_id)
  {
    case PROP_QID_RESPONSE_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      break;

    case PROP_QID_RESPONSE_QID:
      if (self->qid != NULL)
        g_free (self->qid);
      self->qid = g_value_dup_string (value);
      break;

    case PROP_QID_RESPONSE_NEXT_REQUEST_OFFSET:
      self->nextRequestOffset = g_value_get_int64 (value);
      self->__isset_nextRequestOffset = TRUE;
      break;

    case PROP_QID_RESPONSE_MESSAGES:
      if (self->messages != NULL)
        g_ptr_array_unref (self->messages);
      self->messages = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
qid_response_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  QidResponse *self = QID_RESPONSE (object);

  switch (property_id)
  {
    case PROP_QID_RESPONSE_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_QID_RESPONSE_QID:
      g_value_set_string (value, self->qid);
      break;

    case PROP_QID_RESPONSE_NEXT_REQUEST_OFFSET:
      g_value_set_int64 (value, self->nextRequestOffset);
      break;

    case PROP_QID_RESPONSE_MESSAGES:
      g_value_set_boxed (value, self->messages);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
qid_response_instance_init (QidResponse * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->topic = NULL;
  object->qid = NULL;
  object->nextRequestOffset = 0;
  object->__isset_nextRequestOffset = FALSE;
  object->messages = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
qid_response_finalize (GObject *object)
{
  QidResponse *tobject = QID_RESPONSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->qid != NULL)
  {
    g_free(tobject->qid);
    tobject->qid = NULL;
  }
  if (tobject->messages != NULL)
  {
    g_ptr_array_unref (tobject->messages);
    tobject->messages = NULL;
  }
}

static void
qid_response_class_init (QidResponseClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = qid_response_read;
  struct_class->write = qid_response_write;

  gobject_class->finalize = qid_response_finalize;
  gobject_class->get_property = qid_response_get_property;
  gobject_class->set_property = qid_response_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QID_RESPONSE_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QID_RESPONSE_QID,
     g_param_spec_string ("qid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QID_RESPONSE_NEXT_REQUEST_OFFSET,
     g_param_spec_int64 ("nextRequestOffset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QID_RESPONSE_MESSAGES,
     g_param_spec_boxed ("messages",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
qid_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (QidResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) qid_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (QidResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc) qid_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "QidResponseType",
                                   &type_info, 0);
  }

  return type;
}

enum _FetchResponseProperties
{
  PROP_FETCH_RESPONSE_0,
  PROP_FETCH_RESPONSE_CODE,
  PROP_FETCH_RESPONSE_RESULTS
};

/* reads a fetch_response object */
static gint32
fetch_response_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FetchResponse * this_object = FETCH_RESPONSE(object);
  gboolean isset_results = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              QidResponse * _elem16 = NULL;
              if ( _elem16 != NULL)
              {
                g_object_unref (_elem16);
              }
              _elem16 = g_object_new (TYPE_QID_RESPONSE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem16), protocol, error)) < 0)
              {
                g_object_unref (_elem16);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->results, _elem16);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_results = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_results)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
fetch_response_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FetchResponse * this_object = FETCH_RESPONSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FetchResponse", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_code == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "results", T_LIST, 10, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->results->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i17;
    for (i17=0; i17<this_object->results->len; i17++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->results, i17))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
fetch_response_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  FetchResponse *self = FETCH_RESPONSE (object);

  switch (property_id)
  {
    case PROP_FETCH_RESPONSE_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_FETCH_RESPONSE_RESULTS:
      if (self->results != NULL)
        g_ptr_array_unref (self->results);
      self->results = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
fetch_response_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  FetchResponse *self = FETCH_RESPONSE (object);

  switch (property_id)
  {
    case PROP_FETCH_RESPONSE_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_FETCH_RESPONSE_RESULTS:
      g_value_set_boxed (value, self->results);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
fetch_response_instance_init (FetchResponse * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->results = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
fetch_response_finalize (GObject *object)
{
  FetchResponse *tobject = FETCH_RESPONSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->results != NULL)
  {
    g_ptr_array_unref (tobject->results);
    tobject->results = NULL;
  }
}

static void
fetch_response_class_init (FetchResponseClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = fetch_response_read;
  struct_class->write = fetch_response_write;

  gobject_class->finalize = fetch_response_finalize;
  gobject_class->get_property = fetch_response_get_property;
  gobject_class->set_property = fetch_response_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_RESPONSE_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FETCH_RESPONSE_RESULTS,
     g_param_spec_boxed ("results",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
fetch_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FetchResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) fetch_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FetchResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc) fetch_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FetchResponseType",
                                   &type_info, 0);
  }

  return type;
}

enum _AckResultProperties
{
  PROP_ACK_RESULT_0,
  PROP_ACK_RESULT_CONSUMER_ID,
  PROP_ACK_RESULT_GROUP_ID,
  PROP_ACK_RESULT_CLUSTER,
  PROP_ACK_RESULT_OFFSETS
};

/* reads a ack_result object */
static gint32
ack_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AckResult * this_object = ACK_RESULT(object);
  gboolean isset_consumerId = FALSE;
  gboolean isset_groupId = FALSE;
  gboolean isset_cluster = FALSE;
  gboolean isset_offsets = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->consumerId != NULL)
          {
            g_free(this_object->consumerId);
            this_object->consumerId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->consumerId, error)) < 0)
            return -1;
          xfer += ret;
          isset_consumerId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->groupId != NULL)
          {
            g_free(this_object->groupId);
            this_object->groupId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->cluster != NULL)
          {
            g_free(this_object->cluster);
            this_object->cluster = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cluster, error)) < 0)
            return -1;
          xfer += ret;
          isset_cluster = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key18 = NULL;
              GHashTable * val19 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
              if (key18 != NULL)
              {
                g_free(key18);
                key18 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key18, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                guint32 i;
                for (i = 0; i < size; i++)
                {
                  gchar * key20 = NULL;
                  gint64* val21 = g_new (gint64, 1);
                  if (key20 != NULL)
                  {
                    g_free(key20);
                    key20 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &key20, error)) < 0)
                    return -1;
                  xfer += ret;
                  if ((ret = thrift_protocol_read_i64 (protocol, &*val21, error)) < 0)
                    return -1;
                  xfer += ret;
                  g_hash_table_insert ((GHashTable *)val19, (gpointer) key20, (gpointer) val21);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_hash_table_insert ((GHashTable *)this_object->offsets, (gpointer) key18, (gpointer) val19);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_offsets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_consumerId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_groupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_cluster)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_offsets)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
ack_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AckResult * this_object = ACK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AckResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "consumerId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->consumerId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->groupId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cluster", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->cluster, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offsets", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_MAP, (gint32) g_hash_table_size ((GHashTable *) this_object->offsets), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key22 = NULL;
    GHashTable * val23 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
    g_hash_table_foreach ((GHashTable *) this_object->offsets, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key22 = keys[i];
      val23 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->offsets), (gpointer) key22);

      if ((ret = thrift_protocol_write_string (protocol,  key22, error)) < 0)
        return -1;
      {
        if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I64, (gint32) g_hash_table_size ((GHashTable *)  val23), error)) < 0)
          return -1;
        xfer += ret;

        GList *key_list = NULL, *iter = NULL;
        gchar * key24 = NULL;
        gint64* val25 = g_new (gint64, 1);
        g_hash_table_foreach ((GHashTable *)  val23, thrift_hash_table_get_keys, &key_list);
        gchar * keys[g_list_length (key_list)];
        int i=0, key_count = g_list_length (key_list);
        for (iter = g_list_first (key_list); iter; iter = iter->next)
        {
          keys[i++] = (gchar *) iter->data;
        }
        g_list_free (key_list);

        for (i = 0; i < key_count; ++i)
        {
          key24 = keys[i];
          val25 = (gint64*) g_hash_table_lookup (((GHashTable *)  val23), (gpointer) key24);

          if ((ret = thrift_protocol_write_string (protocol,  key24, error)) < 0)
            return -1;
          if ((ret = thrift_protocol_write_i64 (protocol, * val25, error)) < 0)
            return -1;
        }
        if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ack_result_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  AckResult *self = ACK_RESULT (object);

  switch (property_id)
  {
    case PROP_ACK_RESULT_CONSUMER_ID:
      if (self->consumerId != NULL)
        g_free (self->consumerId);
      self->consumerId = g_value_dup_string (value);
      break;

    case PROP_ACK_RESULT_GROUP_ID:
      if (self->groupId != NULL)
        g_free (self->groupId);
      self->groupId = g_value_dup_string (value);
      break;

    case PROP_ACK_RESULT_CLUSTER:
      if (self->cluster != NULL)
        g_free (self->cluster);
      self->cluster = g_value_dup_string (value);
      break;

    case PROP_ACK_RESULT_OFFSETS:
      if (self->offsets != NULL)
        g_hash_table_unref (self->offsets);
      self->offsets = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ack_result_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  AckResult *self = ACK_RESULT (object);

  switch (property_id)
  {
    case PROP_ACK_RESULT_CONSUMER_ID:
      g_value_set_string (value, self->consumerId);
      break;

    case PROP_ACK_RESULT_GROUP_ID:
      g_value_set_string (value, self->groupId);
      break;

    case PROP_ACK_RESULT_CLUSTER:
      g_value_set_string (value, self->cluster);
      break;

    case PROP_ACK_RESULT_OFFSETS:
      g_value_set_boxed (value, self->offsets);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ack_result_instance_init (AckResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->consumerId = NULL;
  object->groupId = NULL;
  object->cluster = NULL;
  object->offsets = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_hash_table_destroy);
}

static void 
ack_result_finalize (GObject *object)
{
  AckResult *tobject = ACK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->consumerId != NULL)
  {
    g_free(tobject->consumerId);
    tobject->consumerId = NULL;
  }
  if (tobject->groupId != NULL)
  {
    g_free(tobject->groupId);
    tobject->groupId = NULL;
  }
  if (tobject->cluster != NULL)
  {
    g_free(tobject->cluster);
    tobject->cluster = NULL;
  }
  if (tobject->offsets != NULL)
  {
    g_hash_table_destroy (tobject->offsets);
    tobject->offsets = NULL;
  }
}

static void
ack_result_class_init (AckResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ack_result_read;
  struct_class->write = ack_result_write;

  gobject_class->finalize = ack_result_finalize;
  gobject_class->get_property = ack_result_get_property;
  gobject_class->set_property = ack_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ACK_RESULT_CONSUMER_ID,
     g_param_spec_string ("consumerId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ACK_RESULT_GROUP_ID,
     g_param_spec_string ("groupId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ACK_RESULT_CLUSTER,
     g_param_spec_string ("cluster",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ACK_RESULT_OFFSETS,
     g_param_spec_boxed ("offsets",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
ack_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AckResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ack_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AckResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) ack_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AckResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumeStatsProperties
{
  PROP_CONSUME_STATS_0,
  PROP_CONSUME_STATS_GROUP,
  PROP_CONSUME_STATS_TOPIC,
  PROP_CONSUME_STATS_CONSUME_OFFSETS,
  PROP_CONSUME_STATS_PRODUCE_OFFSETS
};

/* reads a consume_stats object */
static gint32
consume_stats_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumeStats * this_object = CONSUME_STATS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->group != NULL)
          {
            g_free(this_object->group);
            this_object->group = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->group, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_group = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->topic != NULL)
          {
            g_free(this_object->topic);
            this_object->topic = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->topic, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_topic = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key26 = NULL;
              gint64* val27 = g_new (gint64, 1);
              if (key26 != NULL)
              {
                g_free(key26);
                key26 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key26, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i64 (protocol, &*val27, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->consumeOffsets, (gpointer) key26, (gpointer) val27);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_consumeOffsets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key28 = NULL;
              gint64* val29 = g_new (gint64, 1);
              if (key28 != NULL)
              {
                g_free(key28);
                key28 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key28, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i64 (protocol, &*val29, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->produceOffsets, (gpointer) key28, (gpointer) val29);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_produceOffsets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consume_stats_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumeStats * this_object = CONSUME_STATS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumeStats", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "group", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->group, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "topic", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->topic, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "consumeOffsets", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->consumeOffsets), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key30 = NULL;
    gint64* val31 = g_new (gint64, 1);
    g_hash_table_foreach ((GHashTable *) this_object->consumeOffsets, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key30 = keys[i];
      val31 = (gint64*) g_hash_table_lookup (((GHashTable *) this_object->consumeOffsets), (gpointer) key30);

      if ((ret = thrift_protocol_write_string (protocol,  key30, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol, * val31, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "produceOffsets", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I64, (gint32) g_hash_table_size ((GHashTable *) this_object->produceOffsets), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key32 = NULL;
    gint64* val33 = g_new (gint64, 1);
    g_hash_table_foreach ((GHashTable *) this_object->produceOffsets, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key32 = keys[i];
      val33 = (gint64*) g_hash_table_lookup (((GHashTable *) this_object->produceOffsets), (gpointer) key32);

      if ((ret = thrift_protocol_write_string (protocol,  key32, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_i64 (protocol, * val33, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consume_stats_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  ConsumeStats *self = CONSUME_STATS (object);

  switch (property_id)
  {
    case PROP_CONSUME_STATS_GROUP:
      if (self->group != NULL)
        g_free (self->group);
      self->group = g_value_dup_string (value);
      self->__isset_group = TRUE;
      break;

    case PROP_CONSUME_STATS_TOPIC:
      if (self->topic != NULL)
        g_free (self->topic);
      self->topic = g_value_dup_string (value);
      self->__isset_topic = TRUE;
      break;

    case PROP_CONSUME_STATS_CONSUME_OFFSETS:
      if (self->consumeOffsets != NULL)
        g_hash_table_unref (self->consumeOffsets);
      self->consumeOffsets = g_value_dup_boxed (value);
      self->__isset_consumeOffsets = TRUE;
      break;

    case PROP_CONSUME_STATS_PRODUCE_OFFSETS:
      if (self->produceOffsets != NULL)
        g_hash_table_unref (self->produceOffsets);
      self->produceOffsets = g_value_dup_boxed (value);
      self->__isset_produceOffsets = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consume_stats_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  ConsumeStats *self = CONSUME_STATS (object);

  switch (property_id)
  {
    case PROP_CONSUME_STATS_GROUP:
      g_value_set_string (value, self->group);
      break;

    case PROP_CONSUME_STATS_TOPIC:
      g_value_set_string (value, self->topic);
      break;

    case PROP_CONSUME_STATS_CONSUME_OFFSETS:
      g_value_set_boxed (value, self->consumeOffsets);
      break;

    case PROP_CONSUME_STATS_PRODUCE_OFFSETS:
      g_value_set_boxed (value, self->produceOffsets);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consume_stats_instance_init (ConsumeStats * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->group = NULL;
  object->__isset_group = FALSE;
  object->topic = NULL;
  object->__isset_topic = FALSE;
  object->consumeOffsets = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_consumeOffsets = FALSE;
  object->produceOffsets = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_produceOffsets = FALSE;
}

static void 
consume_stats_finalize (GObject *object)
{
  ConsumeStats *tobject = CONSUME_STATS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->group != NULL)
  {
    g_free(tobject->group);
    tobject->group = NULL;
  }
  if (tobject->topic != NULL)
  {
    g_free(tobject->topic);
    tobject->topic = NULL;
  }
  if (tobject->consumeOffsets != NULL)
  {
    g_hash_table_destroy (tobject->consumeOffsets);
    tobject->consumeOffsets = NULL;
  }
  if (tobject->produceOffsets != NULL)
  {
    g_hash_table_destroy (tobject->produceOffsets);
    tobject->produceOffsets = NULL;
  }
}

static void
consume_stats_class_init (ConsumeStatsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consume_stats_read;
  struct_class->write = consume_stats_write;

  gobject_class->finalize = consume_stats_finalize;
  gobject_class->get_property = consume_stats_get_property;
  gobject_class->set_property = consume_stats_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_GROUP,
     g_param_spec_string ("group",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_TOPIC,
     g_param_spec_string ("topic",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_CONSUME_OFFSETS,
     g_param_spec_boxed ("consumeOffsets",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUME_STATS_PRODUCE_OFFSETS,
     g_param_spec_boxed ("produceOffsets",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
consume_stats_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumeStatsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consume_stats_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumeStats),
      0, /* n_preallocs */
      (GInstanceInitFunc) consume_stats_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumeStatsType",
                                   &type_info, 0);
  }

  return type;
}

enum _PullExceptionProperties
{
  PROP_PULL_EXCEPTION_0,
  PROP_PULL_EXCEPTION_CODE,
  PROP_PULL_EXCEPTION_MESSAGE
};

/* reads a pull_exception object */
static gint32
pull_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PullException * this_object = PULL_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
pull_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PullException * this_object = PULL_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PullException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
pull_exception_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  PullException *self = PULL_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_PULL_EXCEPTION_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_PULL_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
pull_exception_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  PullException *self = PULL_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_PULL_EXCEPTION_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_PULL_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
pull_exception_instance_init (PullException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
pull_exception_finalize (GObject *object)
{
  PullException *tobject = PULL_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
pull_exception_class_init (PullExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = pull_exception_read;
  struct_class->write = pull_exception_write;

  gobject_class->finalize = pull_exception_finalize;
  gobject_class->get_property = pull_exception_get_property;
  gobject_class->set_property = pull_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_EXCEPTION_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PULL_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
pull_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PullExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) pull_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PullException),
      0, /* n_preallocs */
      (GInstanceInitFunc) pull_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PullExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define PULL_EXCEPTION_ERROR_DOMAIN "pull_exception_error_quark"
GQuark
pull_exception_error_quark (void)
{
  return g_quark_from_static_string (PULL_EXCEPTION_ERROR_DOMAIN);
}

/* constants */

enum _ConsumerServicePullArgsProperties
{
  PROP_CONSUMER_SERVICE_PULL_ARGS_0,
  PROP_CONSUMER_SERVICE_PULL_ARGS_REQUEST
};

/* reads a consumer_service_pull_args object */
static gint32
consumer_service_pull_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServicePullArgs * this_object = CONSUMER_SERVICE_PULL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_request = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_pull_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServicePullArgs * this_object = CONSUMER_SERVICE_PULL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServicePullArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_pull_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ConsumerServicePullArgs *self = CONSUMER_SERVICE_PULL_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_PULL_ARGS_REQUEST:
      if (self->request != NULL)
        g_object_unref (self->request);
      self->request = g_value_dup_object (value);
      self->__isset_request = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_pull_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ConsumerServicePullArgs *self = CONSUMER_SERVICE_PULL_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_PULL_ARGS_REQUEST:
      g_value_set_object (value, self->request);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_pull_args_instance_init (ConsumerServicePullArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->request = g_object_new (TYPE_PULL_REQUEST, NULL);
  object->__isset_request = FALSE;
}

static void 
consumer_service_pull_args_finalize (GObject *object)
{
  ConsumerServicePullArgs *tobject = CONSUMER_SERVICE_PULL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->request != NULL)
  {
    g_object_unref(tobject->request);
    tobject->request = NULL;
  }
}

static void
consumer_service_pull_args_class_init (ConsumerServicePullArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_pull_args_read;
  struct_class->write = consumer_service_pull_args_write;

  gobject_class->finalize = consumer_service_pull_args_finalize;
  gobject_class->get_property = consumer_service_pull_args_get_property;
  gobject_class->set_property = consumer_service_pull_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_PULL_ARGS_REQUEST,
     g_param_spec_object ("request",
                         NULL,
                         NULL,
                         TYPE_PULL_REQUEST,
                         G_PARAM_READWRITE));
}

GType
consumer_service_pull_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServicePullArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_pull_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServicePullArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_pull_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServicePullArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServicePullResultProperties
{
  PROP_CONSUMER_SERVICE_PULL_RESULT_0,
  PROP_CONSUMER_SERVICE_PULL_RESULT_SUCCESS,
  PROP_CONSUMER_SERVICE_PULL_RESULT_ERROR
};

/* reads a consumer_service_pull_result object */
static gint32
consumer_service_pull_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServicePullResult * this_object = CONSUMER_SERVICE_PULL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->error != NULL)
          {
            g_object_unref (this_object->error);
          }
          this_object->error = g_object_new (TYPE_PULL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            g_object_unref (this_object->error);
            this_object->error = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_pull_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServicePullResult * this_object = CONSUMER_SERVICE_PULL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServicePullResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_pull_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ConsumerServicePullResult *self = CONSUMER_SERVICE_PULL_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_PULL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CONSUMER_SERVICE_PULL_RESULT_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_pull_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ConsumerServicePullResult *self = CONSUMER_SERVICE_PULL_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_PULL_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CONSUMER_SERVICE_PULL_RESULT_ERROR:
      g_value_set_object (value, self->error);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_pull_result_instance_init (ConsumerServicePullResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PULL_RESPONSE, NULL);
  object->__isset_success = FALSE;
  object->error = NULL;
  object->__isset_error = FALSE;
}

static void 
consumer_service_pull_result_finalize (GObject *object)
{
  ConsumerServicePullResult *tobject = CONSUMER_SERVICE_PULL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
}

static void
consumer_service_pull_result_class_init (ConsumerServicePullResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_pull_result_read;
  struct_class->write = consumer_service_pull_result_write;

  gobject_class->finalize = consumer_service_pull_result_finalize;
  gobject_class->get_property = consumer_service_pull_result_get_property;
  gobject_class->set_property = consumer_service_pull_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_PULL_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PULL_RESPONSE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_PULL_RESULT_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_PULL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
consumer_service_pull_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServicePullResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_pull_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServicePullResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_pull_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServicePullResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceSubmitArgsProperties
{
  PROP_CONSUMER_SERVICE_SUBMIT_ARGS_0,
  PROP_CONSUMER_SERVICE_SUBMIT_ARGS_RESULT
};

/* reads a consumer_service_submit_args object */
static gint32
consumer_service_submit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceSubmitArgs * this_object = CONSUMER_SERVICE_SUBMIT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_result = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_submit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceSubmitArgs * this_object = CONSUMER_SERVICE_SUBMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceSubmitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "result", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_submit_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ConsumerServiceSubmitArgs *self = CONSUMER_SERVICE_SUBMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_SUBMIT_ARGS_RESULT:
      if (self->result != NULL)
        g_object_unref (self->result);
      self->result = g_value_dup_object (value);
      self->__isset_result = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_submit_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ConsumerServiceSubmitArgs *self = CONSUMER_SERVICE_SUBMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_SUBMIT_ARGS_RESULT:
      g_value_set_object (value, self->result);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_submit_args_instance_init (ConsumerServiceSubmitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->result = g_object_new (TYPE_CONSUME_RESULT, NULL);
  object->__isset_result = FALSE;
}

static void 
consumer_service_submit_args_finalize (GObject *object)
{
  ConsumerServiceSubmitArgs *tobject = CONSUMER_SERVICE_SUBMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->result != NULL)
  {
    g_object_unref(tobject->result);
    tobject->result = NULL;
  }
}

static void
consumer_service_submit_args_class_init (ConsumerServiceSubmitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_submit_args_read;
  struct_class->write = consumer_service_submit_args_write;

  gobject_class->finalize = consumer_service_submit_args_finalize;
  gobject_class->get_property = consumer_service_submit_args_get_property;
  gobject_class->set_property = consumer_service_submit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_SUBMIT_ARGS_RESULT,
     g_param_spec_object ("result",
                         NULL,
                         NULL,
                         TYPE_CONSUME_RESULT,
                         G_PARAM_READWRITE));
}

GType
consumer_service_submit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceSubmitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_submit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceSubmitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_submit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceSubmitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceSubmitResultProperties
{
  PROP_CONSUMER_SERVICE_SUBMIT_RESULT_0,
  PROP_CONSUMER_SERVICE_SUBMIT_RESULT_SUCCESS,
  PROP_CONSUMER_SERVICE_SUBMIT_RESULT_ERROR
};

/* reads a consumer_service_submit_result object */
static gint32
consumer_service_submit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceSubmitResult * this_object = CONSUMER_SERVICE_SUBMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->error != NULL)
          {
            g_object_unref (this_object->error);
          }
          this_object->error = g_object_new (TYPE_PULL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            g_object_unref (this_object->error);
            this_object->error = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_submit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceSubmitResult * this_object = CONSUMER_SERVICE_SUBMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceSubmitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_submit_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  ConsumerServiceSubmitResult *self = CONSUMER_SERVICE_SUBMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_SUBMIT_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CONSUMER_SERVICE_SUBMIT_RESULT_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_submit_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  ConsumerServiceSubmitResult *self = CONSUMER_SERVICE_SUBMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_SUBMIT_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_CONSUMER_SERVICE_SUBMIT_RESULT_ERROR:
      g_value_set_object (value, self->error);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_submit_result_instance_init (ConsumerServiceSubmitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->error = NULL;
  object->__isset_error = FALSE;
}

static void 
consumer_service_submit_result_finalize (GObject *object)
{
  ConsumerServiceSubmitResult *tobject = CONSUMER_SERVICE_SUBMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
}

static void
consumer_service_submit_result_class_init (ConsumerServiceSubmitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_submit_result_read;
  struct_class->write = consumer_service_submit_result_write;

  gobject_class->finalize = consumer_service_submit_result_finalize;
  gobject_class->get_property = consumer_service_submit_result_get_property;
  gobject_class->set_property = consumer_service_submit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_SUBMIT_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_SUBMIT_RESULT_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_PULL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
consumer_service_submit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceSubmitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_submit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceSubmitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_submit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceSubmitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceGetConsumeStatsArgsProperties
{
  PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS_0,
  PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS_REQUEST
};

/* reads a consumer_service_get_consume_stats_args object */
static gint32
consumer_service_get_consume_stats_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceGetConsumeStatsArgs * this_object = CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_request = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_get_consume_stats_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceGetConsumeStatsArgs * this_object = CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceGetConsumeStatsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_get_consume_stats_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  ConsumerServiceGetConsumeStatsArgs *self = CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS_REQUEST:
      if (self->request != NULL)
        g_object_unref (self->request);
      self->request = g_value_dup_object (value);
      self->__isset_request = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_get_consume_stats_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  ConsumerServiceGetConsumeStatsArgs *self = CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS_REQUEST:
      g_value_set_object (value, self->request);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_get_consume_stats_args_instance_init (ConsumerServiceGetConsumeStatsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->request = g_object_new (TYPE_CONSUME_STATS_REQUEST, NULL);
  object->__isset_request = FALSE;
}

static void 
consumer_service_get_consume_stats_args_finalize (GObject *object)
{
  ConsumerServiceGetConsumeStatsArgs *tobject = CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->request != NULL)
  {
    g_object_unref(tobject->request);
    tobject->request = NULL;
  }
}

static void
consumer_service_get_consume_stats_args_class_init (ConsumerServiceGetConsumeStatsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_get_consume_stats_args_read;
  struct_class->write = consumer_service_get_consume_stats_args_write;

  gobject_class->finalize = consumer_service_get_consume_stats_args_finalize;
  gobject_class->get_property = consumer_service_get_consume_stats_args_get_property;
  gobject_class->set_property = consumer_service_get_consume_stats_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_ARGS_REQUEST,
     g_param_spec_object ("request",
                         NULL,
                         NULL,
                         TYPE_CONSUME_STATS_REQUEST,
                         G_PARAM_READWRITE));
}

GType
consumer_service_get_consume_stats_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceGetConsumeStatsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_get_consume_stats_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceGetConsumeStatsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_get_consume_stats_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceGetConsumeStatsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceGetConsumeStatsResultProperties
{
  PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_0,
  PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_SUCCESS,
  PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_ERROR
};

/* reads a consumer_service_get_consume_stats_result object */
static gint32
consumer_service_get_consume_stats_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceGetConsumeStatsResult * this_object = CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              ConsumeStats * _elem34 = NULL;
              if ( _elem34 != NULL)
              {
                g_object_unref (_elem34);
              }
              _elem34 = g_object_new (TYPE_CONSUME_STATS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem34), protocol, error)) < 0)
              {
                g_object_unref (_elem34);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem34);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->error != NULL)
          {
            g_object_unref (this_object->error);
          }
          this_object->error = g_object_new (TYPE_PULL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            g_object_unref (this_object->error);
            this_object->error = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_get_consume_stats_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceGetConsumeStatsResult * this_object = CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceGetConsumeStatsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i35;
      for (i35=0; i35<this_object->success->len; i35++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i35))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_get_consume_stats_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  ConsumerServiceGetConsumeStatsResult *self = CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_get_consume_stats_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  ConsumerServiceGetConsumeStatsResult *self = CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_ERROR:
      g_value_set_object (value, self->error);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_get_consume_stats_result_instance_init (ConsumerServiceGetConsumeStatsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->error = NULL;
  object->__isset_error = FALSE;
}

static void 
consumer_service_get_consume_stats_result_finalize (GObject *object)
{
  ConsumerServiceGetConsumeStatsResult *tobject = CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
}

static void
consumer_service_get_consume_stats_result_class_init (ConsumerServiceGetConsumeStatsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_get_consume_stats_result_read;
  struct_class->write = consumer_service_get_consume_stats_result_write;

  gobject_class->finalize = consumer_service_get_consume_stats_result_finalize;
  gobject_class->get_property = consumer_service_get_consume_stats_result_get_property;
  gobject_class->set_property = consumer_service_get_consume_stats_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_GET_CONSUME_STATS_RESULT_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_PULL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
consumer_service_get_consume_stats_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceGetConsumeStatsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_get_consume_stats_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceGetConsumeStatsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_get_consume_stats_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceGetConsumeStatsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceFetchArgsProperties
{
  PROP_CONSUMER_SERVICE_FETCH_ARGS_0,
  PROP_CONSUMER_SERVICE_FETCH_ARGS_REQUEST
};

/* reads a consumer_service_fetch_args object */
static gint32
consumer_service_fetch_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceFetchArgs * this_object = CONSUMER_SERVICE_FETCH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_request = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_fetch_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceFetchArgs * this_object = CONSUMER_SERVICE_FETCH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceFetchArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_fetch_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ConsumerServiceFetchArgs *self = CONSUMER_SERVICE_FETCH_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_FETCH_ARGS_REQUEST:
      if (self->request != NULL)
        g_object_unref (self->request);
      self->request = g_value_dup_object (value);
      self->__isset_request = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_fetch_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ConsumerServiceFetchArgs *self = CONSUMER_SERVICE_FETCH_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_FETCH_ARGS_REQUEST:
      g_value_set_object (value, self->request);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_fetch_args_instance_init (ConsumerServiceFetchArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->request = g_object_new (TYPE_FETCH_REQUEST, NULL);
  object->__isset_request = FALSE;
}

static void 
consumer_service_fetch_args_finalize (GObject *object)
{
  ConsumerServiceFetchArgs *tobject = CONSUMER_SERVICE_FETCH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->request != NULL)
  {
    g_object_unref(tobject->request);
    tobject->request = NULL;
  }
}

static void
consumer_service_fetch_args_class_init (ConsumerServiceFetchArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_fetch_args_read;
  struct_class->write = consumer_service_fetch_args_write;

  gobject_class->finalize = consumer_service_fetch_args_finalize;
  gobject_class->get_property = consumer_service_fetch_args_get_property;
  gobject_class->set_property = consumer_service_fetch_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_FETCH_ARGS_REQUEST,
     g_param_spec_object ("request",
                         NULL,
                         NULL,
                         TYPE_FETCH_REQUEST,
                         G_PARAM_READWRITE));
}

GType
consumer_service_fetch_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceFetchArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_fetch_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceFetchArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_fetch_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceFetchArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceFetchResultProperties
{
  PROP_CONSUMER_SERVICE_FETCH_RESULT_0,
  PROP_CONSUMER_SERVICE_FETCH_RESULT_SUCCESS
};

/* reads a consumer_service_fetch_result object */
static gint32
consumer_service_fetch_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceFetchResult * this_object = CONSUMER_SERVICE_FETCH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_fetch_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceFetchResult * this_object = CONSUMER_SERVICE_FETCH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceFetchResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_fetch_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ConsumerServiceFetchResult *self = CONSUMER_SERVICE_FETCH_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_FETCH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_fetch_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ConsumerServiceFetchResult *self = CONSUMER_SERVICE_FETCH_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_FETCH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_fetch_result_instance_init (ConsumerServiceFetchResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FETCH_RESPONSE, NULL);
  object->__isset_success = FALSE;
}

static void 
consumer_service_fetch_result_finalize (GObject *object)
{
  ConsumerServiceFetchResult *tobject = CONSUMER_SERVICE_FETCH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
consumer_service_fetch_result_class_init (ConsumerServiceFetchResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_fetch_result_read;
  struct_class->write = consumer_service_fetch_result_write;

  gobject_class->finalize = consumer_service_fetch_result_finalize;
  gobject_class->get_property = consumer_service_fetch_result_get_property;
  gobject_class->set_property = consumer_service_fetch_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_FETCH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FETCH_RESPONSE,
                         G_PARAM_READWRITE));
}

GType
consumer_service_fetch_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceFetchResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_fetch_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceFetchResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_fetch_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceFetchResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceAckArgsProperties
{
  PROP_CONSUMER_SERVICE_ACK_ARGS_0,
  PROP_CONSUMER_SERVICE_ACK_ARGS_RESULT
};

/* reads a consumer_service_ack_args object */
static gint32
consumer_service_ack_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceAckArgs * this_object = CONSUMER_SERVICE_ACK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_result = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_ack_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceAckArgs * this_object = CONSUMER_SERVICE_ACK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceAckArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "result", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_ack_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ConsumerServiceAckArgs *self = CONSUMER_SERVICE_ACK_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_ACK_ARGS_RESULT:
      if (self->result != NULL)
        g_object_unref (self->result);
      self->result = g_value_dup_object (value);
      self->__isset_result = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_ack_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ConsumerServiceAckArgs *self = CONSUMER_SERVICE_ACK_ARGS (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_ACK_ARGS_RESULT:
      g_value_set_object (value, self->result);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_ack_args_instance_init (ConsumerServiceAckArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->result = g_object_new (TYPE_ACK_RESULT, NULL);
  object->__isset_result = FALSE;
}

static void 
consumer_service_ack_args_finalize (GObject *object)
{
  ConsumerServiceAckArgs *tobject = CONSUMER_SERVICE_ACK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->result != NULL)
  {
    g_object_unref(tobject->result);
    tobject->result = NULL;
  }
}

static void
consumer_service_ack_args_class_init (ConsumerServiceAckArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_ack_args_read;
  struct_class->write = consumer_service_ack_args_write;

  gobject_class->finalize = consumer_service_ack_args_finalize;
  gobject_class->get_property = consumer_service_ack_args_get_property;
  gobject_class->set_property = consumer_service_ack_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_ACK_ARGS_RESULT,
     g_param_spec_object ("result",
                         NULL,
                         NULL,
                         TYPE_ACK_RESULT,
                         G_PARAM_READWRITE));
}

GType
consumer_service_ack_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceAckArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_ack_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceAckArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_ack_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceAckArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConsumerServiceAckResultProperties
{
  PROP_CONSUMER_SERVICE_ACK_RESULT_0,
  PROP_CONSUMER_SERVICE_ACK_RESULT_SUCCESS
};

/* reads a consumer_service_ack_result object */
static gint32
consumer_service_ack_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConsumerServiceAckResult * this_object = CONSUMER_SERVICE_ACK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
consumer_service_ack_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConsumerServiceAckResult * this_object = CONSUMER_SERVICE_ACK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConsumerServiceAckResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
consumer_service_ack_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ConsumerServiceAckResult *self = CONSUMER_SERVICE_ACK_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_ACK_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
consumer_service_ack_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ConsumerServiceAckResult *self = CONSUMER_SERVICE_ACK_RESULT (object);

  switch (property_id)
  {
    case PROP_CONSUMER_SERVICE_ACK_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
consumer_service_ack_result_instance_init (ConsumerServiceAckResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
consumer_service_ack_result_finalize (GObject *object)
{
  ConsumerServiceAckResult *tobject = CONSUMER_SERVICE_ACK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
consumer_service_ack_result_class_init (ConsumerServiceAckResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = consumer_service_ack_result_read;
  struct_class->write = consumer_service_ack_result_write;

  gobject_class->finalize = consumer_service_ack_result_finalize;
  gobject_class->get_property = consumer_service_ack_result_get_property;
  gobject_class->set_property = consumer_service_ack_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONSUMER_SERVICE_ACK_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
consumer_service_ack_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConsumerServiceAckResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) consumer_service_ack_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConsumerServiceAckResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) consumer_service_ack_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConsumerServiceAckResultType",
                                   &type_info, 0);
  }

  return type;
}

